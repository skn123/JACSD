! Change OMP to $OMP in the comments below to enable OpenMP loop parallelization.

SUBROUTINE DGENDAT(N, ISEED, XS_F, XS_G, XL_X, XF, DF, XG, DG, XX, DX, XWORK, INFO)
  IMPLICIT NONE
#include "qx_wp.fi"

  REAL(WP), PARAMETER :: ZERO = (0.0E0_WP, 0.0E0_WP), ONE = (1.0E0_WP, 0.0E0_WP)

  INTEGER, INTENT(IN) :: N, ISEED(4)
  REAL(WP), INTENT(IN) :: XS_F(N), XS_G(N), XL_X(N)
  DOUBLE PRECISION, INTENT(OUT) :: DF(N,N), DG(N,N), DX(N,N)
  REAL(WP), INTENT(OUT) :: XF(N,N), XG(N,N), XX(N,N), XWORK(3*N)
  INTEGER, INTENT(OUT) :: INFO

  INTEGER :: P, Q
  EXTERNAL :: SEEDOK, QGEMM, QLAGSY, QLAROR

  INFO = 0

  IF (N .LT. 0) THEN
     INFO = -1
     RETURN
  END IF
  CALL SEEDOK(ISEED, INFO)
  IF (INFO .NE. 0) THEN
     INFO = -2
     RETURN
  END IF

  CALL QLAGSY(N, N-1, XL_X, XX, N, ISEED, XWORK, INFO)
  IF (INFO .NE. 0) RETURN
  !OMP PARALLEL DO DEFAULT(NONE) SHARED(N,XX,DX) PRIVATE(P,Q)
  DO Q = 1, N
     DO P = 1, N
        DX(P,Q) = DBLE(XX(P,Q))
     END DO
  END DO
  !OMP END PARALLEL DO

  !OMP PARALLEL DO DEFAULT(NONE) SHARED(N,XF,XS_F) PRIVATE(P,Q)
  DO Q = 1, N
     DO P = 1, Q-1
        XF(P,Q) = ZERO
     END DO
     XF(Q,Q) = XS_F(Q)
     DO P = Q+1, N
        XF(P,Q) = ZERO
     END DO
  END DO
  !OMP END PARALLEL DO

  CALL QLAROR('L', 'N', N, N, XF, N, ISEED, XWORK, INFO)
  IF (INFO .NE. 0) RETURN

  CALL QGEMM('N', 'N', N, N, N, ONE, XF, N, XX, N, ZERO, XG, N)
  !OMP PARALLEL DO DEFAULT(NONE) SHARED(N,XG,DF) PRIVATE(P,Q)
  DO Q = 1, N
     DO P = 1, N
        DF(P,Q) = DBLE(XG(P,Q))
     END DO
  END DO
  !OMP END PARALLEL DO

  !OMP PARALLEL DO DEFAULT(NONE) SHARED(N,XG,XS_G) PRIVATE(P,Q)
  DO Q = 1, N
     DO P = 1, Q-1
        XG(P,Q) = ZERO
     END DO
     XG(Q,Q) = XS_G(Q)
     DO P = Q+1, N
        XG(P,Q) = ZERO
     END DO
  END DO
  !OMP END PARALLEL DO

  CALL QLAROR('L', 'N', N, N, XG, N, ISEED, XWORK, INFO)
  IF (INFO .NE. 0) RETURN

  CALL QGEMM('N', 'N', N, N, N, ONE, XG, N, XX, N, ZERO, XF, N)
  !OMP PARALLEL DO DEFAULT(NONE) SHARED(N,XF,DG) PRIVATE(P,Q)
  DO Q = 1, N
     DO P = 1, N
        DG(P,Q) = DBLE(XF(P,Q))
     END DO
  END DO
  !OMP END PARALLEL DO
END SUBROUTINE DGENDAT

SUBROUTINE ZGENDAT(N, ISEED, XS_F, XS_G, XL_X, XF, ZF, XG, ZG, XX, ZX, XWORK, INFO)
  IMPLICIT NONE
#include "qx_wp.fi"

  REAL(WP), PARAMETER :: ZERO = 0.0E0_WP, ONE = 1.0E0_WP

  INTEGER, INTENT(IN) :: N, ISEED(4)
  REAL(WP), INTENT(IN) :: XS_F(N), XS_G(N), XL_X(N)
  DOUBLE COMPLEX, INTENT(OUT) :: ZF(N,N), ZG(N,N), ZX(N,N)
  COMPLEX(WP), INTENT(OUT) :: XF(N,N), XG(N,N), XX(N,N), XWORK(3*N)
  INTEGER, INTENT(OUT) :: INFO

  INTEGER :: P, Q
  EXTERNAL :: SEEDOK, XGEMM, XLAGHE, XLAROR

  INFO = 0

  IF (N .LT. 0) THEN
     INFO = -1
     RETURN
  END IF
  CALL SEEDOK(ISEED, INFO)
  IF (INFO .NE. 0) THEN
     INFO = -2
     RETURN
  END IF

  CALL XLAGHE(N, N-1, XL_X, XX, N, ISEED, XWORK, INFO)
  IF (INFO .NE. 0) RETURN
  !OMP PARALLEL DO DEFAULT(NONE) SHARED(N,XX,ZX) PRIVATE(P,Q)
  DO Q = 1, N
     DO P = 1, N
        ZX(P,Q) = DCMPLX(DBLE(REAL(XX(P,Q))), DBLE(AIMAG(XX(P,Q))))
     END DO
  END DO
  !OMP END PARALLEL DO

  !OMP PARALLEL DO DEFAULT(NONE) SHARED(N,XF,XS_F) PRIVATE(P,Q)
  DO Q = 1, N
     DO P = 1, Q-1
        XF(P,Q) = ZERO
     END DO
     XF(Q,Q) = XS_F(Q)
     DO P = Q+1, N
        XF(P,Q) = ZERO
     END DO
  END DO
  !OMP END PARALLEL DO

  CALL XLAROR('L', 'N', N, N, XF, N, ISEED, XWORK, INFO)
  IF (INFO .NE. 0) RETURN

  CALL XGEMM('N', 'N', N, N, N, ONE, XF, N, XX, N, ZERO, XG, N)
  !OMP PARALLEL DO DEFAULT(NONE) SHARED(N,XG,ZF) PRIVATE(P,Q)
  DO Q = 1, N
     DO P = 1, N
        ZF(P,Q) = DCMPLX(DBLE(REAL(XG(P,Q))), DBLE(AIMAG(XG(P,Q))))
     END DO
  END DO
  !OMP END PARALLEL DO

  !OMP PARALLEL DO DEFAULT(NONE) SHARED(N,XG,XS_G) PRIVATE(P,Q)
  DO Q = 1, N
     DO P = 1, Q-1
        XG(P,Q) = ZERO
     END DO
     XG(Q,Q) = XS_G(Q)
     DO P = Q+1, N
        XG(P,Q) = ZERO
     END DO
  END DO
  !OMP END PARALLEL DO

  CALL XLAROR('L', 'N', N, N, XG, N, ISEED, XWORK, INFO)
  IF (INFO .NE. 0) RETURN

  CALL XGEMM('N', 'N', N, N, N, ONE, XG, N, XX, N, ZERO, XF, N)
  !OMP PARALLEL DO DEFAULT(NONE) SHARED(N,XF,ZG) PRIVATE(P,Q)
  DO Q = 1, N
     DO P = 1, N
        ZG(P,Q) = DCMPLX(DBLE(REAL(XF(P,Q))), DBLE(AIMAG(XF(P,Q))))
     END DO
  END DO
  !OMP END PARALLEL DO
END SUBROUTINE ZGENDAT
