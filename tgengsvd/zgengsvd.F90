PROGRAM ZGENGSVD
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: OUTPUT_UNIT, ERROR_UNIT
  USE BIO
  USE SEED
  USE LAMGEN
  USE DATGEN
  IMPLICIT NONE

  INTEGER, PARAMETER :: WP = QX_WP
  INTEGER, PARAMETER :: FNL = 252
  DOUBLE PRECISION, PARAMETER :: ZERO = 0.0D0

  ! command-line parameters
  INTEGER :: SEEDI, N, IDIST_F, IDIST_G, IDIST_X, INFO
  DOUBLE PRECISION :: EPS_F, SCAL_F, EPS_G, SCAL_G, EPS_X, SCAL_X
  CHARACTER(LEN=FNL) :: SIGMA_F, SIGMA_G, LAMBDA_X, FIL

  INTEGER :: ISEED(4), K, L, P, LWORK
  DOUBLE PRECISION :: TOLA, TOLB, ULP, UNFL
  DOUBLE COMPLEX :: WORK1(1)
  REAL(KIND=WP) :: H

  INTEGER, ALLOCATABLE :: IWORK(:)

  DOUBLE PRECISION, ALLOCATABLE :: DS_F(:), DS_G(:), DS(:), DL_X(:), DWORK(:)
  DOUBLE COMPLEX, ALLOCATABLE :: TAU(:), ZWORK(:)
  REAL(KIND=WP), ALLOCATABLE :: QS_F(:), QS_G(:), QL_X(:)
  COMPLEX(KIND=WP), ALLOCATABLE :: XWORK(:)

  DOUBLE COMPLEX, ALLOCATABLE :: ZF(:,:), ZG(:,:), ZU(:,:), ZV(:,:), ZQ(:,:)
  COMPLEX(KIND=WP), ALLOCATABLE :: XF(:,:), XG(:,:), XX(:,:)

  DOUBLE PRECISION, EXTERNAL :: DLAMCH, ZLANGE
  EXTERNAL :: ZGGSVP3

  CALL READCL(SIGMA_F, SIGMA_G, LAMBDA_X, SEEDI, N, FIL, &
       IDIST_F, EPS_F, SCAL_F, IDIST_G, EPS_G, SCAL_G, IDIST_X, EPS_X, SCAL_X, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'READCL'
  END IF

  CALL SEEDIX(SEEDI, ISEED, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'SEEDIX'
  END IF

  ALLOCATE(DS_F(N))
  IF (IDIST_F .NE. 0) THEN
     CALL DGENLAM(N, ISEED, IDIST_F, EPS_F, SCAL_F, DS_F, P, INFO)
  ELSE
     CALL DTXTLAM(SIGMA_F, N, DS_F, P, INFO)
  END IF
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'SIGMA_F'
  END IF
  IF (P .NE. N) THEN
     WRITE (ERROR_UNIT,*) P, '<', N
     ERROR STOP 'SIGMA_F'
  END IF

  ALLOCATE(DS_G(N))
  IF (IDIST_G .NE. 0) THEN
     CALL DGENLAM(N, ISEED, IDIST_G, EPS_G, SCAL_G, DS_G, P, INFO)
  ELSE
     CALL DTXTLAM(SIGMA_G, N, DS_G, P, INFO)
  END IF
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'SIGMA_G'
  END IF
  IF (P .NE. N) THEN
     WRITE (ERROR_UNIT,*) P, '<', N
     ERROR STOP 'SIGMA_G'
  END IF

  ALLOCATE(DS(N))
  DO P = 1, N
     DS(P) = DS_F(P) / DS_G(P)
  END DO

  ALLOCATE(DL_X(N))
  IF (IDIST_X .NE. 0) THEN
     CALL DGENLAM(N, ISEED, IDIST_X, EPS_X, SCAL_X, DL_X, P, INFO)
  ELSE
     CALL DTXTLAM(LAMBDA_X, N, DL_X, P, INFO)
  END IF
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'LAMBDA_X'
  END IF

  ALLOCATE(ZF(N,N))
  ALLOCATE(ZG(N,N))
  ALLOCATE(ZU(N,N))

  ALLOCATE(XF(N,N))
  ALLOCATE(XG(N,N))
  ALLOCATE(XX(N,N))

  ALLOCATE(QS_F(N))
  ALLOCATE(QS_G(N))
  ALLOCATE(QL_X(N))

  DO P = 1, N
     QS_F(P) = REAL(DS_F(P),WP)
     QS_G(P) = REAL(DS_G(P),WP)
     QL_X(P) = REAL(DL_X(P),WP)

     H = HYPOT(QS_F(P), QS_G(P))
     QS_F(P) = QS_F(P) / H
     QS_G(P) = QS_G(P) / H

     DS_F(P) = DBLE(QS_F(P))
     DS_G(P) = DBLE(QS_G(P))
  END DO

  P = 3 * N
  ALLOCATE(XWORK(P))
  CALL ZGENDAT(N, ISEED, QS_F, QS_G, QL_X, XF, ZF, XG, ZG, XX, ZU, XWORK, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'ZGENDAT'
  END IF
  DEALLOCATE(XWORK)

  DEALLOCATE(QL_X)
  DEALLOCATE(QS_G)
  DEALLOCATE(QS_F)

  DEALLOCATE(XX)
  DEALLOCATE(XG)
  DEALLOCATE(XF)

#ifdef USE_GGSVP3
  ALLOCATE(ZV(N,N))
  ALLOCATE(ZQ(N,N))

  ALLOCATE(IWORK(N))
  P = 2 * N
  ALLOCATE(DWORK(P))
  ALLOCATE(TAU(N))

  TOLA = ZERO
  TOLB = ZERO
  WORK1 = DCMPLX(ZERO, ZERO)
  LWORK = -1
  CALL ZGGSVP3('U', 'V', 'Q', N, N, N, ZF,N, ZG,N, TOLA,TOLB, K, L, ZU,N, ZV,N, ZQ,N, IWORK, DWORK, TAU, WORK1, LWORK, INFO)
  LWORK = MAX(1,CEILING(DBLE(WORK1(1))))
  ALLOCATE(ZWORK(LWORK))

  TOLA = ZLANGE('1', N, N, ZF, N, DWORK) ! M=N x N
  TOLB = ZLANGE('1', N, N, ZG, N, DWORK) ! P=N x N
  ULP = DLAMCH('P') ! Precision
  UNFL = DLAMCH('S') ! Safe Minimum
  TOLA = N * MAX(TOLA,UNFL) * ULP ! N=MAX(M,N)
  TOLB = N * MAX(TOLB,UNFL) * ULP ! N=MAX(P,N)

  CALL ZGGSVP3('U', 'V', 'Q', N, N, N, ZF,N, ZG,N, TOLA,TOLB, K, L, ZU,N, ZV,N, ZQ,N, IWORK, DWORK, TAU, ZWORK, LWORK, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'ZGGSVP3'
  END IF

  DEALLOCATE(ZWORK)
  DEALLOCATE(TAU)
  DEALLOCATE(DWORK)
  DEALLOCATE(IWORK)

  P = -1
  CALL BIO_OPEN(P, TRIM(FIL)//'.QQ', 'WO', INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_OPEN(QQ)'
  END IF
  CALL BIO_WRITE_Z2(P, N, N, ZQ, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_WRITE_Z2(QQ)'
  END IF
  CALL BIO_CLOSE(P, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_CLOSE(QQ)'
  END IF
  DEALLOCATE(ZQ)

  P = -1
  CALL BIO_OPEN(P, TRIM(FIL)//'.QV', 'WO', INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_OPEN(QV)'
  END IF
  CALL BIO_WRITE_Z2(P, N, N, ZV, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_WRITE_Z2(QV)'
  END IF
  CALL BIO_CLOSE(P, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_CLOSE(QV)'
  END IF
  DEALLOCATE(ZV)

  P = -1
  CALL BIO_OPEN(P, TRIM(FIL)//'.QU', 'WO', INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_OPEN(QU)'
  END IF
  CALL BIO_WRITE_Z2(P, N, N, ZU, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_WRITE_Z2(QU)'
  END IF
  CALL BIO_CLOSE(P, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_CLOSE(QU)'
  END IF
  DEALLOCATE(ZU)
#endif

  P = -1
  CALL BIO_OPEN(P, TRIM(FIL)//'.W', 'WO', INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_OPEN(W)'
  END IF
  CALL BIO_WRITE_Z2(P, N, N, ZG, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_WRITE_Z2(W)'
  END IF
  CALL BIO_CLOSE(P, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_CLOSE(W)'
  END IF
  DEALLOCATE(ZG)

  P = -1
  CALL BIO_OPEN(P, TRIM(FIL)//'.Y', 'WO', INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_OPEN(Y)'
  END IF
  CALL BIO_WRITE_Z2(P, N, N, ZF, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_WRITE_Z2(Y)'
  END IF
  CALL BIO_CLOSE(P, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_CLOSE(Y)'
  END IF
  DEALLOCATE(ZF)

  P = -1
  CALL BIO_OPEN(P, TRIM(FIL)//'.LX', 'WO', INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_OPEN(LX)'
  END IF
  CALL BIO_WRITE_D1(P, N, DL_X, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_WRITE_D1(LX)'
  END IF
  CALL BIO_CLOSE(P, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_CLOSE(LX)'
  END IF
  DEALLOCATE(DL_X)

  P = -1
  CALL BIO_OPEN(P, TRIM(FIL)//'.SS', 'WO', INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_OPEN(SS)'
  END IF
  CALL BIO_WRITE_D1(P, N, DS, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_WRITE_D1(SS)'
  END IF
  CALL BIO_CLOSE(P, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_CLOSE(SS)'
  END IF
  DEALLOCATE(DS)

  P = -1
  CALL BIO_OPEN(P, TRIM(FIL)//'.SW', 'WO', INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_OPEN(SW)'
  END IF
  CALL BIO_WRITE_D1(P, N, DS_G, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_WRITE_D1(SW)'
  END IF
  CALL BIO_CLOSE(P, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_CLOSE(SW)'
  END IF
  DEALLOCATE(DS_G)

  P = -1
  CALL BIO_OPEN(P, TRIM(FIL)//'.SY', 'WO', INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_OPEN(SY)'
  END IF
  CALL BIO_WRITE_D1(P, N, DS_F, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_WRITE_D1(SY)'
  END IF
  CALL BIO_CLOSE(P, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,*) INFO
     ERROR STOP 'BIO_CLOSE(SY)'
  END IF
  DEALLOCATE(DS_F)

CONTAINS

  SUBROUTINE READCL(SIGMA_F, SIGMA_G, LAMBDA_X, SEEDI, N, FIL, &
       IDIST_F, EPS_F, SCAL_F, IDIST_G, EPS_G, SCAL_G, IDIST_X, EPS_X, SCAL_X, INFO)
    IMPLICIT NONE

    INTEGER, INTENT(OUT) :: SEEDI, N, IDIST_F, IDIST_G, IDIST_X, INFO
    DOUBLE PRECISION, INTENT(OUT) :: EPS_F, SCAL_F, EPS_G, SCAL_G, EPS_X, SCAL_X
    CHARACTER(LEN=*), INTENT(OUT) :: SIGMA_F, SIGMA_G, LAMBDA_X, FIL

    INTEGER, PARAMETER :: NRQP = 6
    INTEGER :: NXTA
    CHARACTER(LEN=FNL) :: CAS

    SEEDI = 0
    N = 0
    IDIST_F = 0
    IDIST_G = 0
    IDIST_X = 0
    INFO = 0

    EPS_F = ZERO
    SCAL_F = ZERO
    EPS_G = ZERO
    SCAL_G = ZERO
    EPS_X = ZERO
    SCAL_X = ZERO

    SIGMA_F = ''
    SIGMA_G = ''
    LAMBDA_X = ''
    FIL = ''

    NXTA = NRQP
    CAS = ''

    IF (COMMAND_ARGUMENT_COUNT() .LT. NRQP) THEN
       WRITE (OUTPUT_UNIT,*) 'zgengsvd.exe SIGMA_F SIGMA_G LAMBDA_X SEEDIX N FILE [ SIG|LAM_PARAMS ]'
       WRITE (OUTPUT_UNIT,*) '>> COMMAND LINE (INPUT) ARGUMENTS <<'
       WRITE (OUTPUT_UNIT,*) 'SIGMA_F : \Sigma_F; 1, 3, or FILENAME'
       WRITE (OUTPUT_UNIT,*) 'SIGMA_G : \Sigma_G; 1, 3, or FILENAME'
       WRITE (OUTPUT_UNIT,*) 'LAMBDA_X: \Lambda_X; 1, 2, 3, or FILENAME'
       WRITE (OUTPUT_UNIT,*) 'IDIST123: 1 [uniform (0,1)], 2 [uniform(-1,1)], or 3 [normal(0,1)]'
       WRITE (OUTPUT_UNIT,*) 'FILENAME: SIG|LAM.txt: max 252 chars, >= N lines [each line = one real value]'
       WRITE (OUTPUT_UNIT,*) 'SEEDIX  : index of hard-coded pRNG seed (see seedix.F90); 1 or 2'
       WRITE (OUTPUT_UNIT,*) 'N       : order of the output matrix: > 0'
       WRITE (OUTPUT_UNIT,*) 'FILE    : output file name prefix: max 252 chars'
       WRITE (OUTPUT_UNIT,*) 'SIG|LAM ; SIG|LAM_PARAMS if SIG|LAM is IDIST123'
       WRITE (OUTPUT_UNIT,*) ' EPS_F  : \sigma''_i survives iff |\sigma''_i| > EPS_F'
       WRITE (OUTPUT_UNIT,*) ' SCALE_F: final \sigma_i = \sigma''_i * SCALE_F'
       WRITE (OUTPUT_UNIT,*) ' EPS_G  : \sigma''_i survives iff |\sigma''_i| > EPS_G'
       WRITE (OUTPUT_UNIT,*) ' SCALE_G: final \sigma_i = \sigma''_i * SCALE_G'
       WRITE (OUTPUT_UNIT,*) ' EPS_X  : \lambda''_i survives iff |\lambda''_i| > EPS_X'
       WRITE (OUTPUT_UNIT,*) ' SCALE_X: final \lambda_i = \lambda''_i * SCALE_X'
       WRITE (OUTPUT_UNIT,*) '<< OUTPUT DATASETS >>'
       WRITE (OUTPUT_UNIT,*) 'FILE.SY : double precision(N); \Sigma_F normalized: \sigma_F^2 + \sigma_G^2 = 1'
       WRITE (OUTPUT_UNIT,*) 'FILE.SW : double precision(N); \Sigma_G normalized: \sigma_F^2 + \sigma_G^2 = 1'
       WRITE (OUTPUT_UNIT,*) 'FILE.SS : double precision(N); \Sigma: \sigma_F / \sigma_G'
       WRITE (OUTPUT_UNIT,*) 'FILE.LX : double precision(N); \Lambda_X as read/generated'
       WRITE (OUTPUT_UNIT,*) 'FILE.Y  : double complex(N,N); F = U_F \Sigma_F X'
       WRITE (OUTPUT_UNIT,*) 'FILE.W  : double complex(N,N); G = U_G \Sigma_G X'
#ifdef USE_GGSVP3
       WRITE (OUTPUT_UNIT,*) 'FILE.QU : double complex(N,N); U: see LaPACK zggsvp3.f'
       WRITE (OUTPUT_UNIT,*) 'FILE.QV : double complex(N,N); V: see LaPACK zggsvp3.f'
       WRITE (OUTPUT_UNIT,*) 'FILE.QQ : double complex(N,N); Q: see LaPACK zggsvp3.f'
#endif
       INFO = 1
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(1, SIGMA_F, STATUS=INFO)
    IF (INFO .NE. 0) THEN
       INFO = -1
       RETURN
    END IF
    IF (TRIM(SIGMA_F) .EQ. '1') THEN
       IDIST_F = 1
    ELSE IF (TRIM(SIGMA_F) .EQ. '3') THEN
       IDIST_F = 3
    END IF

    CALL GET_COMMAND_ARGUMENT(2, SIGMA_G, STATUS=INFO)
    IF (INFO .NE. 0) THEN
       INFO = -2
       RETURN
    END IF
    IF (TRIM(SIGMA_G) .EQ. '1') THEN
       IDIST_G = 1
    ELSE IF (TRIM(SIGMA_G) .EQ. '3') THEN
       IDIST_G = 3
    END IF

    CALL GET_COMMAND_ARGUMENT(3, LAMBDA_X, STATUS=INFO)
    IF (INFO .NE. 0) THEN
       INFO = -3
       RETURN
    END IF
    IF (TRIM(LAMBDA_X) .EQ. '1') THEN
       IDIST_X = 1
    ELSE IF (TRIM(LAMBDA_X) .EQ. '2') THEN
       IDIST_X = 2
    ELSE IF (TRIM(LAMBDA_X) .EQ. '3') THEN
       IDIST_X = 3
    END IF

    CALL GET_COMMAND_ARGUMENT(4, CAS, STATUS=INFO)
    IF (INFO .NE. 0) THEN
       INFO = -4
       RETURN
    END IF
    READ (CAS,*) SEEDI
    IF (SEEDI .LE. 0) THEN
       INFO = -4
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(5, CAS, STATUS=INFO)
    IF (INFO .NE. 0) THEN
       INFO = -5
       RETURN
    END IF
    READ (CAS,*) N
    IF (N .LE. 0) THEN
       INFO = -5
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(6, FIL, STATUS=INFO)
    IF (INFO .NE. 0) THEN
       INFO = -6
       RETURN
    END IF

    IF (IDIST_F .NE. 0) THEN
       NXTA = NXTA + 1
       CALL GET_COMMAND_ARGUMENT(NXTA, CAS, STATUS=INFO)
       IF (INFO .NE. 0) THEN
          INFO = -NXTA
          RETURN
       END IF
       READ (CAS,*) EPS_F
       IF (EPS_F .LT. ZERO) THEN
          INFO = -NXTA
          RETURN
       END IF
       NXTA = NXTA + 1
       CALL GET_COMMAND_ARGUMENT(NXTA, CAS, STATUS=INFO)
       IF (INFO .NE. 0) THEN
          INFO = -NXTA
          RETURN
       END IF
       READ (CAS,*) SCAL_F
       IF (SCAL_F .EQ. ZERO) THEN
          INFO = -NXTA
          RETURN
       END IF
    END IF

    IF (IDIST_G .NE. 0) THEN
       NXTA = NXTA + 1
       CALL GET_COMMAND_ARGUMENT(NXTA, CAS, STATUS=INFO)
       IF (INFO .NE. 0) THEN
          INFO = -NXTA
          RETURN
       END IF
       READ (CAS,*) EPS_G
       IF (EPS_G .LT. ZERO) THEN
          INFO = -NXTA
          RETURN
       END IF
       NXTA = NXTA + 1
       CALL GET_COMMAND_ARGUMENT(NXTA, CAS, STATUS=INFO)
       IF (INFO .NE. 0) THEN
          INFO = -NXTA
          RETURN
       END IF
       READ (CAS,*) SCAL_G
       IF (SCAL_G .EQ. ZERO) THEN
          INFO = -NXTA
          RETURN
       END IF
    END IF

    IF (IDIST_X .NE. 0) THEN
       NXTA = NXTA + 1
       CALL GET_COMMAND_ARGUMENT(NXTA, CAS, STATUS=INFO)
       IF (INFO .NE. 0) THEN
          INFO = -NXTA
          RETURN
       END IF
       READ (CAS,*) EPS_X
       IF (EPS_X .LT. ZERO) THEN
          INFO = -NXTA
          RETURN
       END IF
       NXTA = NXTA + 1
       CALL GET_COMMAND_ARGUMENT(NXTA, CAS, STATUS=INFO)
       IF (INFO .NE. 0) THEN
          INFO = -NXTA
          RETURN
       END IF
       READ (CAS,*) SCAL_X
       IF (SCAL_X .EQ. ZERO) THEN
          INFO = -NXTA
          RETURN
       END IF
    END IF
  END SUBROUTINE READCL

END PROGRAM ZGENGSVD
