MODULE DATGEN
  USE SEED
  IMPLICIT NONE
#include "qx_wp.fi"

  PRIVATE :: WP
  REAL(KIND=WP), PARAMETER, PRIVATE :: QZERO = 0.0_WP

CONTAINS

  SUBROUTINE DGENDAT(N, ISEED, QLAMBDA, QA, DA, QWORK, INFO)
    IMPLICIT NONE

    INTEGER, INTENT(IN) :: N, ISEED(4)
    REAL(KIND=WP), INTENT(IN) :: QLAMBDA(N)
    DOUBLE PRECISION, INTENT(OUT) :: DA(N,N)
    REAL(KIND=WP), INTENT(OUT) :: QA(N,N), QWORK(2*N)
    INTEGER, INTENT(OUT) :: INFO

    INTEGER :: P, Q
    EXTERNAL :: QLARGE

    INFO = 0

    IF (N .LT. 0) THEN
       INFO = -1
       RETURN
    END IF
    CALL SEEDOK(ISEED, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -2
       RETURN
    END IF

    !$OMP PARALLEL DO DEFAULT(NONE) SHARED(N,QA) PRIVATE(P,Q)
    DO Q = 1, N
       DO P = 1, N
          QA(P,Q) = QZERO
       END DO
    END DO
    !$OMP END PARALLEL DO

    !$OMP PARALLEL DO DEFAULT(NONE) SHARED(N,QA,QLAMBDA) PRIVATE(Q)
    DO Q = 1, N, 2
       QA(Q+1,Q) = QLAMBDA(Q)
       QA(Q,Q+1) = QLAMBDA(Q+1)
    END DO
    !$OMP END PARALLEL DO

    CALL QLARGE(N, QA, N, ISEED, QWORK, INFO)
    IF (INFO .NE. 0) RETURN

    !$OMP PARALLEL DO DEFAULT(NONE) SHARED(N,QA) PRIVATE(P,Q) SCHEDULE(NONMONOTONIC:DYNAMIC,1)
    DO Q = 1, N
       QA(Q,Q) = QZERO
       DO P = Q+1, N
          QA(P,Q) = SCALE(QA(P,Q) - QA(Q,P), -1)
          QA(Q,P) = -QA(P,Q)
       END DO
    END DO
    !$OMP END PARALLEL DO

    !$OMP PARALLEL DO DEFAULT(NONE) SHARED(N,QA,DA) PRIVATE(P,Q)
    DO Q = 1, N
       DO P = 1, N
          DA(P,Q) = DBLE(QA(P,Q))
       END DO
    END DO
    !$OMP END PARALLEL DO
  END SUBROUTINE DGENDAT

  SUBROUTINE ZGENDAT(N, ISEED, QLAMBDA, XA, ZA, XWORK, INFO)
    IMPLICIT NONE

    COMPLEX(KIND=WP), PARAMETER :: XZERO = (QZERO, QZERO)

    INTEGER, INTENT(IN) :: N, ISEED(4)
    REAL(KIND=WP), INTENT(IN) :: QLAMBDA(N)
    DOUBLE COMPLEX, INTENT(OUT) :: ZA(N,N)
    COMPLEX(KIND=WP), INTENT(OUT) :: XA(N,N), XWORK(2*N)
    INTEGER, INTENT(OUT) :: INFO

    INTEGER :: P, Q
    EXTERNAL :: XLARGE

    INFO = 0

    IF (N .LT. 0) THEN
       INFO = -1
       RETURN
    END IF
    CALL SEEDOK(ISEED, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -2
       RETURN
    END IF

    !$OMP PARALLEL DO DEFAULT(NONE) SHARED(N,XA,QLAMBDA) PRIVATE(P,Q)
    DO Q = 1, N
       DO P = 1, Q-1
          XA(P,Q) = XZERO
       END DO
       XA(Q,Q) = CMPLX(QZERO, QLAMBDA(Q), WP)
       DO P = Q+1, N
          XA(P,Q) = XZERO
       END DO
    END DO
    !$OMP END PARALLEL DO

    CALL XLARGE(N, XA, N, ISEED, XWORK, INFO)
    IF (INFO .NE. 0) RETURN

    !$OMP PARALLEL DO DEFAULT(NONE) SHARED(N,XA) PRIVATE(P,Q) SCHEDULE(NONMONOTONIC:DYNAMIC,1)
    DO Q = 1, N
       XA(Q,Q) = CMPLX(QZERO, AIMAG(XA(Q,Q)), WP)
       DO P = Q+1, N
          XA(P,Q) = (XA(P,Q) - CONJG(XA(Q,P))) / 2
          XA(Q,P) = -CONJG(XA(P,Q))
       END DO
    END DO
    !$OMP END PARALLEL DO

    !$OMP PARALLEL DO DEFAULT(NONE) SHARED(N,XA,ZA) PRIVATE(P,Q)
    DO Q = 1, N
       DO P = 1, N
          ZA(P,Q) = DCMPLX(REAL(XA(P,Q)), AIMAG(XA(P,Q)))
       END DO
    END DO
    !$OMP END PARALLEL DO
  END SUBROUTINE ZGENDAT

END MODULE DATGEN
