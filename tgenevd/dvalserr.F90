PROGRAM DVALSERR
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: OUTPUT_UNIT, ERROR_UNIT
  USE BIO
  IMPLICIT NONE

  INTEGER, PARAMETER :: WP = QX_WP
  DOUBLE PRECISION, PARAMETER :: D_ZERO = 0.0D0, D_ONE = 1.0D0
  REAL(KIND=WP), PARAMETER :: Q_ZERO = 0.0_WP, Q_ONE = 1.0_WP

  INTEGER, PARAMETER :: FNL = 252
  CHARACTER(LEN=2), PARAMETER :: ACT = 'RO'

  CHARACTER(LEN=FNL) :: FTRUE, FCOMP
  DOUBLE PRECISION :: MINAE, MAXAE, AVGAE, MINRE, MAXRE, AVGRE
  INTEGER :: N, INFO, U

  DOUBLE PRECISION, ALLOCATABLE :: T(:), C(:)
  INTEGER, ALLOCATABLE :: J(:)

  EXTERNAL :: DLASRT

  CALL READCL(N, FTRUE, FCOMP, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I2,A)',ADVANCE='NO') INFO, ' '
     FLUSH(ERROR_UNIT)
     ERROR STOP 'READCL'
  END IF

  ALLOCATE(T(N))
  ALLOCATE(C(N))
  ALLOCATE(J(N))

  WRITE (OUTPUT_UNIT,'(A)') '"L","MINLN","MAXLN","MINLP","MAXLP","MINAE","MAXAE","AVGAE","MINRE","MAXRE","AVGRE"'
  FLUSH(OUTPUT_UNIT)

  U = -1
  CALL BIO_OPEN(U, TRIM(FTRUE)//'.L', ACT, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I2,A)',ADVANCE='NO') INFO, ' '
     FLUSH(ERROR_UNIT)
     ERROR STOP 'BIO_OPEN(L)'
  END IF
  CALL BIO_READ_D1(U, N, T, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I2,A)',ADVANCE='NO') INFO, ' '
     FLUSH(ERROR_UNIT)
     ERROR STOP 'BIO_READ_D1(L)'
  END IF
  CALL BIO_CLOSE(U, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I2,A)',ADVANCE='NO') INFO, ' '
     FLUSH(ERROR_UNIT)
     ERROR STOP 'BIO_CLOSE(L)'
  END IF
  CALL DLASRT('D', N, T, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I2,A)',ADVANCE='NO') INFO, ' '
     FLUSH(ERROR_UNIT)
     ERROR STOP 'DLASRT(L)'
  END IF

  WRITE (OUTPUT_UNIT,'(A)',ADVANCE='NO') '"L"'
  FLUSH(OUTPUT_UNIT)

  IF (SIGN(D_ONE, T(N)) .EQ. D_ONE) THEN
     ! all +
     WRITE (OUTPUT_UNIT,'(4(A,ES25.17E3))',ADVANCE='NO') ',', D_ZERO, ',', D_ZERO, ',', T(N), ',', T(1)
  ELSE IF (SIGN(D_ONE, T(1)) .EQ. -D_ONE) THEN
     ! all -
     WRITE (OUTPUT_UNIT,'(4(A,ES25.17E3))',ADVANCE='NO') ',', T(N), ',', T(1), ',', -D_ZERO, ',', -D_ZERO
  ELSE ! a mix of - and +
     U = N
     DO WHILE (U .GT. 1)
        IF (SIGN(D_ONE, T(U-1)) .EQ. D_ONE) EXIT
        U = U - 1
     END DO
     WRITE (OUTPUT_UNIT,'(4(A,ES25.17E3))',ADVANCE='NO') ',', T(N), ',', T(U), ',', T(U-1), ',', T(1)
  END IF
  FLUSH(OUTPUT_UNIT)

  U = -1
  CALL BIO_OPEN(U, TRIM(FCOMP)//'.E', ACT, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I2,A)',ADVANCE='NO') INFO, ' '
     FLUSH(ERROR_UNIT)
     ERROR STOP 'BIO_OPEN(E)'
  END IF
  CALL BIO_READ_D1(U, N, C, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I2,A)',ADVANCE='NO') INFO, ' '
     FLUSH(ERROR_UNIT)
     ERROR STOP 'BIO_READ_D1(E)'
  END IF
  CALL BIO_CLOSE(U, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I2,A)',ADVANCE='NO') INFO, ' '
     FLUSH(ERROR_UNIT)
     ERROR STOP 'BIO_CLOSE(E)'
  END IF

  CALL DLASRT('D', N, C, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I2,A)',ADVANCE='NO') INFO, ' '
     FLUSH(ERROR_UNIT)
     ERROR STOP 'DLASRT(E)'
  END IF

  CALL ERRSTATS(N, T, C, MINAE, MAXAE, AVGAE, MINRE, MAXRE, AVGRE, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I2,A)',ADVANCE='NO') INFO, ' '
     FLUSH(ERROR_UNIT)
     ERROR STOP 'ERRSTATS'
  END IF
  WRITE (OUTPUT_UNIT,'(6(A,ES25.17E3))') ',', MINAE, ',', MAXAE, ',', AVGAE, ',', MINRE, ',', MAXRE, ',', AVGRE
  FLUSH(OUTPUT_UNIT)

  DEALLOCATE(J)
  DEALLOCATE(C)
  DEALLOCATE(T)

CONTAINS

  PURE SUBROUTINE ERRSTATS(N, T, C, MINAE, MAXAE, AVGAE, MINRE, MAXRE, AVGRE, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: N
    DOUBLE PRECISION, INTENT(IN) :: T(N), C(N)
    DOUBLE PRECISION, INTENT(OUT) :: MINAE, MAXAE, AVGAE, MINRE, MAXRE, AVGRE
    INTEGER, INTENT(OUT) :: INFO

    REAL(KIND=WP) :: Q_MINAE, Q_MAXAE, Q_AVGAE, Q_MINRE, Q_MAXRE, Q_AVGRE
    REAL(KIND=WP) :: Q_AE, Q_RE, Q_ONE_N
    INTEGER :: I

    IF (N .LT. 0) THEN
       INFO = -1
    ELSE
       INFO = 0
    END IF
    IF (INFO .NE. 0) RETURN

    MINAE = D_ZERO
    MAXAE = D_ZERO
    AVGAE = D_ZERO

    MINRE = D_ZERO
    MAXRE = D_ZERO
    AVGRE = D_ZERO

    IF (N .EQ. 0) RETURN

    Q_MINAE = Q_ZERO
    Q_MAXAE = Q_ZERO
    Q_AVGAE = Q_ZERO

    Q_MINRE = Q_ZERO
    Q_MAXRE = Q_ZERO
    Q_AVGRE = Q_ZERO

    Q_ONE_N = Q_ONE / N

    DO I = 1, N
       Q_AE = ABS(REAL(T(I), WP) - REAL(C(I), WP))
       IF (Q_AE .LT. Q_MINAE) Q_MINAE = Q_AE
       IF (Q_AE .GT. Q_MAXAE) Q_MAXAE = Q_AE
       Q_AVGAE = Q_AVGAE + Q_AE * Q_ONE_N

       Q_RE = Q_AE / ABS(REAL(T(I), WP))
       IF (.NOT. (Q_RE .EQ. Q_RE)) Q_RE = Q_ZERO
       IF (Q_RE .LT. Q_MINRE) Q_MINRE = Q_RE
       IF (Q_RE .GT. Q_MAXRE) Q_MAXRE = Q_RE
       Q_AVGRE = Q_AVGRE + Q_RE * Q_ONE_N
    END DO

    MINAE = DBLE(Q_MINAE)
    MAXAE = DBLE(Q_MAXAE)
    AVGAE = DBLE(Q_AVGAE)

    MINRE = DBLE(Q_MINRE)
    MAXRE = DBLE(Q_MAXRE)
    AVGRE = DBLE(Q_AVGRE)
  END SUBROUTINE ERRSTATS

  SUBROUTINE READCL(N, FTRUE, FCOMP, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(OUT) :: N, INFO
    CHARACTER(LEN=*), INTENT(OUT) :: FTRUE, FCOMP

    CHARACTER(LEN=FNL) :: ARG
    INTEGER :: TMP

    INFO = 0
    IF (COMMAND_ARGUMENT_COUNT() .NE. 3) ERROR STOP 'dvalserr.exe N FTRUE FCOMP'

    CALL GET_COMMAND_ARGUMENT(1, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -1
       RETURN
    END IF
    READ (ARG,*) N
    IF (N .LE. 0) THEN
       INFO = 1
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(2, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -2
       RETURN
    END IF
    FTRUE = TRIM(ARG)
    IF (LEN_TRIM(FTRUE) .LE. 0) THEN
       INFO = 2
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(3, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -3
       RETURN
    END IF
    FCOMP = TRIM(ARG)
    IF (LEN_TRIM(FCOMP) .LE. 0) THEN
       INFO = 3
       RETURN
    END IF
  END SUBROUTINE READCL

END PROGRAM DVALSERR
