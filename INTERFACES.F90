INTERFACE FMA
#ifdef NFMA
   PURE FUNCTION SFMA(A, B, C) BIND(C,NAME='fmaf')
     USE, INTRINSIC :: ISO_C_BINDING
     IMPLICIT NONE
     REAL(c_float), INTENT(IN), VALUE :: A, B, C
     REAL(c_float) :: SFMA
   END FUNCTION SFMA
   PURE FUNCTION DFMA(A, B, C) BIND(C,NAME='fma')
     USE, INTRINSIC :: ISO_C_BINDING
     IMPLICIT NONE
     REAL(c_double), INTENT(IN), VALUE :: A, B, C
     REAL(c_double) :: DFMA
   END FUNCTION DFMA
#else
   MODULE PROCEDURE SFMA, DFMA
#endif
END INTERFACE

INTERFACE RSQRT
#ifdef USE_INTEL
   PURE FUNCTION SRSQRT(X) BIND(C,NAME='invsqrtf')
     USE, INTRINSIC :: ISO_C_BINDING
     IMPLICIT NONE
     REAL(c_float), INTENT(IN), VALUE :: X
     REAL(c_float) :: SRSQRT
   END FUNCTION SRSQRT
   PURE FUNCTION DRSQRT(X) BIND(C,NAME='invsqrt')
     USE, INTRINSIC :: ISO_C_BINDING
     IMPLICIT NONE
     REAL(c_double), INTENT(IN), VALUE :: X
     REAL(c_double) :: DRSQRT
   END FUNCTION DRSQRT
#else
   MODULE PROCEDURE SRSQRT, DRSQRT
#endif
END INTERFACE

INTERFACE SINCOS
#ifdef USE_INTEL
   PURE SUBROUTINE SSINCOS(X, S, C) BIND(C,NAME='sincosf')
     USE, INTRINSIC :: ISO_C_BINDING
     IMPLICIT NONE
     REAL(c_float), INTENT(IN), VALUE :: X
     REAL(c_float), INTENT(OUT) :: S, C
   END SUBROUTINE SSINCOS
#else
   MODULE PROCEDURE SSINCOS
#endif
#ifndef USE_GNU
   PURE SUBROUTINE DSINCOS(X, S, C) BIND(C,NAME='sincos')
     USE, INTRINSIC :: ISO_C_BINDING
     IMPLICIT NONE
     REAL(c_double), INTENT(IN), VALUE :: X
     REAL(c_double), INTENT(OUT) :: S, C
   END SUBROUTINE DSINCOS
#else
   MODULE PROCEDURE DSINCOS
#endif
END INTERFACE

INTERFACE
#ifndef USE_ESSL
   PURE SUBROUTINE DROTM(N, DX, INCX, DY, INCY, DPARAM) BIND(C,NAME='drotm_')
     IMPLICIT NONE
     INTEGER, INTENT(IN) :: N, INCX, INCY
     DOUBLE PRECISION, INTENT(INOUT) :: DX(*), DY(*)
     DOUBLE PRECISION, INTENT(IN) :: DPARAM(5)
   END SUBROUTINE DROTM
#else
   MODULE PROCEDURE DROTM
#endif
END INTERFACE

INTERFACE
#ifdef USE_ESSL
   PURE SUBROUTINE DLACPY(UPLO, M, N, A, LDA, B, LDB) BIND(C,NAME='dlacpy')
#else
   PURE SUBROUTINE DLACPY(UPLO, M, N, A, LDA, B, LDB) BIND(C,NAME='dlacpy_')
#endif
     IMPLICIT NONE
     CHARACTER, INTENT(IN) :: UPLO
     INTEGER, INTENT(IN) :: M, N, LDA, LDB
     DOUBLE PRECISION, INTENT(IN) :: A(LDA,*)
     DOUBLE PRECISION, INTENT(OUT) :: B(LDB,*)
   END SUBROUTINE DLACPY
END INTERFACE

INTERFACE
#ifdef USE_ESSL
   PURE SUBROUTINE DLASET(UPLO, M, N, ALPHA, BETA, A, LDA) BIND(C,NAME='dlaset')
#else
   PURE SUBROUTINE DLASET(UPLO, M, N, ALPHA, BETA, A, LDA) BIND(C,NAME='dlaset_')
#endif
     IMPLICIT NONE
     CHARACTER, INTENT(IN) :: UPLO
     INTEGER, INTENT(IN) :: M, N, LDA
     DOUBLE PRECISION, INTENT(IN) :: ALPHA, BETA
     DOUBLE PRECISION, INTENT(OUT) :: A(LDA,*)
   END SUBROUTINE DLASET
END INTERFACE

INTERFACE
   PURE SUBROUTINE JSTRAT_INIT(JS, ID, N, INFO) BIND(C,NAME='jstrat_init_f')
     IMPLICIT NONE
     INTEGER, INTENT(OUT) :: JS(*)
     INTEGER, INTENT(IN) :: ID, N
     INTEGER, INTENT(OUT) :: INFO
   END SUBROUTINE JSTRAT_INIT
END INTERFACE

INTERFACE
   PURE SUBROUTINE JSTRAT_NEXT(JS, ARR, INFO) BIND(C,NAME='jstrat_next_f')
     IMPLICIT NONE
     INTEGER, INTENT(INOUT) :: JS(*)
     INTEGER, INTENT(OUT) :: ARR(2,*)
     INTEGER, INTENT(OUT) :: INFO
   END SUBROUTINE JSTRAT_NEXT
END INTERFACE
