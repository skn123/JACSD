SUBROUTINE INDJAC2(NC1,IFC1, NC2,IFC2, M,N, G0I,G1I,G0J,G1J,LDG, V0I,V1I,V0J,V1J,LDV, NBSIZ2,LDAC,&
     MAXCYC,MAXTHR,JSTRAT, TOL, GB,VB, WORK,LWORK, IWORK,LIWORK, LROTP,INFOP)

  IMPLICIT NONE

  LOGICAL, PARAMETER :: MYFAST = .TRUE.

  INTEGER, INTENT(IN) :: NC1,IFC1, NC2,IFC2, M,N, LDG,LDV, NBSIZ2,LDAC, MAXCYC(2),MAXTHR(2),JSTRAT(2), LWORK,LIWORK
  DOUBLE PRECISION, INTENT(INOUT) :: G0I(LDG,N),G1I(LDG,N), G0J(LDG,N),G1J(LDG,N)
  DOUBLE PRECISION, INTENT(INOUT) :: V0I(LDV,N),V1I(LDV,N), V0J(LDV,N),V1J(LDV,N)
  DOUBLE PRECISION, INTENT(IN) :: TOL
  DOUBLE PRECISION, INTENT(OUT) :: GB(LDAC,NBSIZ2),VB(LDAC,NBSIZ2), WORK(LWORK)
  INTEGER, INTENT(INOUT) :: LROTP(2)
  INTEGER, INTENT(OUT) :: IWORK(LIWORK), INFOP(2)

  INTEGER :: NCF
  DOUBLE PRECISION :: SIGMAP(1)
  INTEGER :: NROTP(2)

  INTEGER, INTRINSIC :: MOD
  EXTERNAL :: DGEMM, DPOTRF, DSYRK
#ifndef USE_ESSL
  EXTERNAL :: DLASET
#endif

  !DIR$ ASSUME_ALIGNED G0I:MALIGN_B,G1I:MALIGN_B, G0J:MALIGN_B,G1J:MALIGN_B
  !DIR$ ASSUME_ALIGNED V0I:MALIGN_B,V1I:MALIGN_B, V0J:MALIGN_B,V1J:MALIGN_B
  !DIR$ ASSUME_ALIGNED GB:MALIGN_B,VB:MALIGN_B, WORK:MALIGN_B, IWORK:MALIGN_B
  !DIR$ ASSUME (MOD(LDG,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LDV,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LDAC,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LWORK,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LIWORK,I_CL1_LEN) .EQ. 0)

  NCF = NC1 + NC2

  CALL DSYRK('U', 'T', NC1, M, D_ONE, G0I(1,IFC1), LDG, D_ZERO, GB(1, 1), LDAC)
  CALL DSYRK('U', 'T', NC2, M, D_ONE, G0J(1,IFC2), LDG, D_ZERO, GB(NC1+1, NC1+1), LDAC)
  CALL DGEMM('T', 'N', NC1, NC2, M, D_ONE, G0I(1,IFC1), LDG, G0J(1,IFC2), LDG, D_ZERO, GB(1, NC1+1), LDAC)

  CALL DPOTRF('U', NCF, GB, LDAC, INFOP(2))
  IF (INFOP(2) .EQ. 0) THEN
     CALL DLASET('L', NCF-1, NCF-1, D_ZERO, D_ZERO, GB(2,1), LDAC)
     IF ((NC1 .EQ. NC2) .OR. (JSTRAT(1) .LT. JSMENC)) THEN
        CALL DJAC1(MYFAST, NCF,NCF, GB,LDAC, VB,LDAC, MAXCYC,MAXTHR,JSTRAT, TOL, SIGMAP,&
             WORK,LWORK, IWORK,LIWORK, NROTP,INFOP)
     ELSE! |NC1 - NC2| = 1 (==> NCF odd ==> no parallel strategy implemented)
        ! Border GB with 1 row and 1 column of zeroes, and set the last diagonal element to 1.
        CALL DLASET('A', NCF, 1, D_ZERO, D_ZERO, GB(1,NCF+1), LDAC)
        CALL DLASET('A', 1, NCF, D_ZERO, D_ZERO, GB(NCF+1,1), LDAC)
        GB(NCF+1,NCF+1) = D_ONE
        CALL DJAC1(MYFAST, NCF+1,NCF+1, GB,LDAC, VB,LDAC, MAXCYC,MAXTHR,JSTRAT, TOL, SIGMAP,&
             WORK,LWORK, IWORK,LIWORK, NROTP,INFOP)
     END IF
     IF (INFOP(1) .EQ. 0) THEN
        IF (NROTP(1) .GT. 0) THEN
           CALL DGEMM('N','N', M,NC1,NC2, D_ONE, G0J(1,IFC2), LDG, VB(NC1+1, 1), LDAC, D_ZERO, G1I(1,IFC1), LDG)
           CALL DGEMM('N','N', M,NC1,NC1, D_ONE, G0I(1,IFC1), LDG, VB(1, 1), LDAC, D_ONE, G1I(1,IFC1), LDG)
           CALL DGEMM('N','N', M,NC2,NC1, D_ONE, G0I(1,IFC1), LDG, VB(1, NC1+1), LDAC, D_ZERO, G1J(1,IFC2), LDG)
           CALL DGEMM('N','N', M,NC2,NC2, D_ONE, G0J(1,IFC2), LDG, VB(NC1+1, NC1+1), LDAC, D_ONE, G1J(1,IFC2), LDG)

           CALL DGEMM('N','N', N,NC1,NC2, D_ONE, V0J(1,IFC2), LDV, VB(NC1+1, 1), LDAC, D_ZERO, V1I(1,IFC1), LDV)
           CALL DGEMM('N','N', N,NC1,NC1, D_ONE, V0I(1,IFC1), LDV, VB(1, 1), LDAC, D_ONE, V1I(1,IFC1), LDV)
           CALL DGEMM('N','N', N,NC2,NC1, D_ONE, V0I(1,IFC1), LDV, VB(1, NC1+1), LDAC, D_ZERO, V1J(1,IFC2), LDV)
           CALL DGEMM('N','N', N,NC2,NC2, D_ONE, V0J(1,IFC2), LDV, VB(NC1+1, NC1+1), LDAC, D_ONE, V1J(1,IFC2), LDV)

           LROTP(1) = LROTP(1) + NROTP(1)
           LROTP(2) = LROTP(2) + NROTP(2)
        ELSE
           INFOP(1) = -1
        END IF
     ELSE
        INFOP(1) = 2
     END IF
  ELSE
     INFOP(1) = 1
  END IF

END SUBROUTINE INDJAC2

SUBROUTINE MYDJAC2(FAST, M, N, G, LDG, V, LDV, MAXCYC, MAXTHR, NBSIZE, NBSIZ2, LDAC, NPAIRS, NBL, JSTRAT, TOL,&
     GSH, VSH, GVB, WORK, LWORK, IWORK, LIWORK, BLKPTR, NC, IFC, JPAIRS, LROTP, INFOP, NROT, INFO)

  IMPLICIT NONE

  INTEGER, PARAMETER :: G0 = 1, G1 = 2, V0 = 3, V1 = 4

  LOGICAL, INTENT(IN) :: FAST
  INTEGER, INTENT(IN) :: M, N, LDG, LDV, MAXCYC(3), MAXTHR(3), NBSIZE, NBSIZ2, LDAC, NPAIRS, NBL, JSTRAT(3), LWORK, LIWORK
  INTEGER, INTENT(OUT) :: IWORK(LIWORK,NPAIRS), BLKPTR(4,NBL), NC(NBL),IFC(NBL),&
       JPAIRS(2,NPAIRS),LROTP(2,NPAIRS),INFOP(2,NPAIRS), NROT(2),INFO(2)
  DOUBLE PRECISION, INTENT(IN) :: TOL
  DOUBLE PRECISION, INTENT(INOUT), TARGET :: G(LDG,N)
  DOUBLE PRECISION, INTENT(OUT), TARGET :: V(LDV,N), GSH(LDG,N), VSH(LDV,N)
  DOUBLE PRECISION, INTENT(OUT) :: GVB(LDAC,NBSIZ2,2,NPAIRS), WORK(LWORK,NPAIRS)

  DOUBLE PRECISION, POINTER :: G0I(:,:),G1I(:,:), V0I(:,:),V1I(:,:)
  DOUBLE PRECISION, POINTER :: G0J(:,:),G1J(:,:), V0J(:,:),V1J(:,:)
  INTEGER :: JS(JSMLEN), LROT(2), STEPS, CYC, STP, BLASNT, PAIR, I,J, NC1,IFC1, NC2,IFC2, U, CLK(3)

  INTEGER, INTRINSIC :: IAND, MOD
#ifndef USE_ESSL
  EXTERNAL :: DLACPY, DLASET
#endif

  !DIR$ ASSUME_ALIGNED G:MALIGN_B,V:MALIGN_B, GSH:MALIGN_B,VSH:MALIGN_B, GVB:MALIGN_B, WORK:MALIGN_B,IWORK:MALIGN_B
  !DIR$ ASSUME_ALIGNED BLKPTR:MALIGN_B, NC:MALIGN_B,IFC:MALIGN_B, JPAIRS:MALIGN_B,LROTP:MALIGN_B,INFOP:MALIGN_B
  !DIR$ ASSUME (MOD(LDG,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LDV,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LDAC,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LWORK,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LIWORK,I_CL1_LEN) .EQ. 0)

  NROT = 0
  INFO = 0

  ! STEPS = ((NBL / NPAIRS) * (NBL - 1)) / 2
  CALL JSTRAT_INIT(JS, JSTRAT(1), NBL, STEPS)
  IF (STEPS .LE. 0) THEN
     INFO(1) = 1
     INFO(2) = STEPS
     RETURN
  END IF

  IF (FAST) THEN
     U = -1
  ELSE
     U = GET_IOUNIT('O')
     IF (U .LT. 0) THEN
        INFO(1) = 2
        INFO(2) = U
        RETURN
     END IF
  END IF

  I = MOD(N, NBL)
  IF (I .EQ. 0) I = NBL
  DO J = 1, I
     NC(J) = NBSIZE
  END DO
  DO J = I+1, NBL
     NC(J) = NBSIZE - 1
  END DO

  IFC(1) = 1
  DO J = 2, NBL
     IFC(J) = IFC(J-1) + NC(J-1)
  END DO

  BLASNT = MAXTHR(2) * MAXTHR(3)
  !$OMP PARALLEL NUM_THREADS(NPAIRS), PRIVATE(I,J)
  J = BLAS_SET_NUM_THREADS(BLASNT)
  !$OMP DO
  DO I = 1, NBL
     CALL DLASET('A', N, NC(I), D_ZERO, D_ZERO, V(1,IFC(I)), LDV)
     DO J = IFC(I), IFC(I)+(NC(I)-1)
        V(J,J) = D_ONE
     END DO
     BLKPTR(G0,I) = TRANSFER(C_LOC(G),0)
     BLKPTR(G1,I) = TRANSFER(C_LOC(GSH),0)
     BLKPTR(V0,I) = TRANSFER(C_LOC(V),0)
     BLKPTR(V1,I) = TRANSFER(C_LOC(VSH),0)
  END DO
  !$OMP END DO
  !$OMP END PARALLEL

  DO CYC = 1, MAXCYC(1)

     IF (.NOT. FAST) CALL TIMER_START(CLK)
     LROTP = 0

     DO STP = 1, STEPS

        CALL JSTRAT_NEXT(JS, JPAIRS, J)
        IF (J .EQ. 0) THEN
           INFO(1) = 3
           INFO(2) = J
           RETURN
        END IF

        !$OMP PARALLEL NUM_THREADS(NPAIRS), PRIVATE(PAIR,I,J,NC1,IFC1,NC2,IFC2,G0I,G1I,V0I,V1I,G0J,G1J,V0J,V1J)
        J = BLAS_SET_NUM_THREADS(BLASNT)
        !$OMP DO
        DO PAIR = 1, NPAIRS
           I = IAND(JPAIRS(1,PAIR), JSMASK) + 1
           J = IAND(JPAIRS(2,PAIR), JSMASK) + 1

           NC1 = NC(I)
           IFC1 = IFC(I)
           NC2 = NC(J)
           IFC2 = IFC(J)

           CALL C_F_POINTER(TRANSFER(BLKPTR(G0,I),C_NULL_PTR), G0I, (/LDG,N/))
           CALL C_F_POINTER(TRANSFER(BLKPTR(G1,I),C_NULL_PTR), G1I, (/LDG,N/))
           CALL C_F_POINTER(TRANSFER(BLKPTR(V0,I),C_NULL_PTR), V0I, (/LDV,N/))
           CALL C_F_POINTER(TRANSFER(BLKPTR(V1,I),C_NULL_PTR), V1I, (/LDV,N/))

           CALL C_F_POINTER(TRANSFER(BLKPTR(G0,J),C_NULL_PTR), G0J, (/LDG,N/))
           CALL C_F_POINTER(TRANSFER(BLKPTR(G1,J),C_NULL_PTR), G1J, (/LDG,N/))
           CALL C_F_POINTER(TRANSFER(BLKPTR(V0,J),C_NULL_PTR), V0J, (/LDV,N/))
           CALL C_F_POINTER(TRANSFER(BLKPTR(V1,J),C_NULL_PTR), V1J, (/LDV,N/))

           CALL INDJAC2(NC1,IFC1, NC2,IFC2, M,N, G0I,G1I,G0J,G1J,LDG, V0I,V1I,V0J,V1J,LDV, NBSIZ2,LDAC,&
                MAXCYC(2),MAXTHR(2),JSTRAT(2), TOL, GVB(1,1,1,PAIR),GVB(1,1,2,PAIR),&
                WORK(1,PAIR),LWORK, IWORK(1,PAIR),LIWORK, LROTP(1,PAIR),INFOP(1,PAIR))

           IF (INFOP(1,PAIR) .EQ. -1) THEN ! no-op
              CONTINUE ! INFOP(1,PAIR) = 0
           ELSE IF (INFOP(1,PAIR) .EQ. 0) THEN ! swap ptr
              BLKPTR(G0,I) = TRANSFER(C_LOC(G1I),0)
              BLKPTR(G1,I) = TRANSFER(C_LOC(G0I),0)
              BLKPTR(V0,I) = TRANSFER(C_LOC(V1I),0)
              BLKPTR(V1,I) = TRANSFER(C_LOC(V0I),0)

              BLKPTR(G0,J) = TRANSFER(C_LOC(G1J),0)
              BLKPTR(G1,J) = TRANSFER(C_LOC(G0J),0)
              BLKPTR(V0,J) = TRANSFER(C_LOC(V1J),0)
              BLKPTR(V1,J) = TRANSFER(C_LOC(V0J),0)
           ELSE
              !$OMP CRITICAL
              INFO(1) = 4 * PAIR
              INFO(2) = INFOP(2,PAIR)
              !$OMP END CRITICAL
           END IF
        END DO
        !$OMP END DO
        !$OMP END PARALLEL

        IF (INFO(1) .NE. 0) RETURN

     END DO ! STP

     LROT = 0
     DO PAIR = 1, NPAIRS
        LROT(1) = LROT(1) + LROTP(1,PAIR)
        LROT(2) = LROT(2) + LROTP(2,PAIR)
     END DO

     NROT(1) = NROT(1) + LROT(1)
     NROT(2) = NROT(2) + LROT(2)
     IF (FAST) THEN
        IF (LROT(1) .EQ. 0) EXIT
     ELSE
        CALL TIMER_STOP(CLK)
        WRITE (UNIT=U, FMT='(A,I3,A,I19,A,I19,A)', ADVANCE='NO') &
             'CYC(',CYC, '),ALLROT(',LROT(1), '),BIGROT(',LROT(2),'), '
        CALL TIMER_PRINT(CLK)
        IF (LROT(2) .EQ. 0) EXIT
     END IF

  END DO ! CYC

  INFO(1) = 0
  INFO(2) = CYC

  !$OMP PARALLEL NUM_THREADS(NPAIRS), PRIVATE(I,J)
  J = BLAS_SET_NUM_THREADS(BLASNT)
  IF (FAST) THEN
     !$OMP DO
     DO I = 1, NBL
        J = IFC(I)
        IF (BLKPTR(V0,I) .EQ. TRANSFER(C_LOC(VSH),0)) CALL DLACPY('A', N, NC(I), VSH(1,J), LDV, V(1,J), LDV)
     END DO
     !$OMP END DO
  ELSE
     !$OMP DO
     DO I = 1, NBL
        J = IFC(I)
        IF (BLKPTR(G0,I) .EQ. TRANSFER(C_LOC(GSH),0)) CALL DLACPY('A', M, NC(I), GSH(1,J), LDG, G(1,J), LDG)
        IF (BLKPTR(V0,I) .EQ. TRANSFER(C_LOC(VSH),0)) CALL DLACPY('A', N, NC(I), VSH(1,J), LDV, V(1,J), LDV)
     END DO
     !$OMP END DO
  END IF
  !$OMP END PARALLEL

END SUBROUTINE MYDJAC2

SUBROUTINE DJAC2(FAST, M, N, G, LDG, V, LDV, MAXCYC, MAXTHR, JSTRAT, TOL, SIGMA,&
     WORK, LWORK, IWORK, LIWORK, NROT, INFO)

  IMPLICIT NONE

  LOGICAL, INTENT(IN) :: FAST
  INTEGER, INTENT(IN) :: M, N, LDG, LDV, MAXCYC(3), MAXTHR(3), JSTRAT(3), LWORK, LIWORK
  INTEGER, INTENT(OUT) :: IWORK(LIWORK), NROT(2), INFO(2)
  DOUBLE PRECISION, INTENT(IN) :: TOL
  DOUBLE PRECISION, INTENT(INOUT) :: G(LDG,N)
  DOUBLE PRECISION, INTENT(OUT) :: V(LDV,N), SIGMA(N), WORK(LWORK)

  INTEGER :: MYMTHR, NPAIRS, MYNBL, NBSIZE, NBSIZ2, LDAC, MYLWRK, MYLIWRK, BLASNT, I, J
  INTEGER :: I_GSH,I_VSH,I_GVB,I_WRK, I_BP,I_NC,I_IFC,I_JP,I_LP,I_IP,I_IWRK
  INTEGER :: L_GSH,L_VSH,L_GVB,L_WRK, L_BP,L_NC,L_IFC,L_JP,L_LP,L_IP,L_IWRK, L_WORK,L_IWORK

  INTEGER, INTRINSIC :: MIN, MOD
  DOUBLE PRECISION, EXTERNAL :: DNRM2
  EXTERNAL :: DSCAL

  !DIR$ ASSUME_ALIGNED G:MALIGN_B,V:MALIGN_B, WORK:MALIGN_B,IWORK:MALIGN_B
  !DIR$ ASSUME (MOD(LDG,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LDV,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LWORK,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LIWORK,I_CL1_LEN) .EQ. 0)

  IF (FAST) GOTO 1

  IF (M .LT. 0) THEN
     INFO(1) = -2
     INFO(2) = M
  ELSE IF (N .LT. 0) THEN
     INFO(1) = -3
     INFO(2) = N
  ELSE IF (N .GT. M) THEN
     INFO(1) = -3
     INFO(2) = N
  ELSE IF (LDG .LT. M) THEN
     INFO(1) = -5
     INFO(2) = LDG
  ELSE IF (LDV .LT. N) THEN
     INFO(1) = -7
     INFO(2) = LDV
  ELSE IF (MAXTHR(1) .LT. 0) THEN
     INFO(1) = -8
     INFO(2) = MAXTHR(1)
  ELSE IF (MAXCYC(1) .LT. 0) THEN
     INFO(1) = -9
     INFO(2) = MAXCYC(1)
  ELSE IF (JSTRAT(1) .LT. 0) THEN
     INFO(1) = -10
     INFO(2) = JSTRAT(1)
  ELSE IF (LWORK .LT. 0) THEN
     INFO(1) = -14
     INFO(2) = LWORK
  ELSE IF (LIWORK .LT. 0) THEN
     INFO(1) = -16
     INFO(2) = LIWORK
  ELSE
     INFO = 0
  END IF

  IF (INFO(1) .NE. 0) THEN
     RETURN
  ELSE IF (N .EQ. 0) THEN
     NROT = 0
     RETURN
  ELSE
     GOTO 2
  END IF

1 INFO = 0
2 CONTINUE

  IF (MAXTHR(1) .EQ. 0) THEN
     MYMTHR = GET_NTHR()
  ELSE
     MYMTHR = MIN(MAXTHR(1), GET_NTHR())
  END IF

  IF (JSTRAT(1) .LT. JSMENC) THEN
     NPAIRS = 1
  ELSE
     NPAIRS = MYMTHR
  END IF
  MYNBL = 2 * NPAIRS

  NBSIZE = (N + (MYNBL - 1)) / MYNBL
  NBSIZ2 = 2 * NBSIZE
  LDAC = NBSIZ2
  J = MOD(LDAC, D_CL1_LEN)
  IF (J .NE. 0) LDAC = LDAC + (D_CL1_LEN - J)

  MYLWRK = 0
  MYLIWRK = 0

  IF (N .EQ. 1) THEN
     CALL DJAC1(FAST, M, N, G, LDG, V, LDV, MAXCYC(2), MAXTHR(2), JSTRAT(2), TOL, SIGMA,&
          WORK, MYLWRK, IWORK, MYLIWRK, NROT, INFO)
     RETURN
  ELSE IF (N .LT. MYNBL) THEN
     CALL DJAC1(FAST, M,N, G, LDG, V, LDV, MAXCYC(2), MAXTHR(2), JSTRAT(2), TOL, SIGMA,&
          WORK, MYLWRK, IWORK, MYLIWRK, NROT, INFO)
     IF (INFO(1) .LT. 0) RETURN
     IF (INFO(1) .GT. 0) MYLWRK = INFO(1)
     IF (INFO(2) .GT. 0) MYLIWRK = INFO(2)
  ELSE
     CALL DJAC1(FAST, M,N, G, LDG, V, LDV, MAXCYC(2), MAXTHR(2), JSTRAT(2), TOL, SIGMA,&
          WORK, MYLWRK, IWORK, MYLIWRK, NROT, INFO)
     IF (INFO(1) .LT. 0) RETURN
     IF (INFO(1) .GT. 0) L_WORK = INFO(1)
     IF (INFO(2) .GT. 0) L_IWORK = INFO(2)

     I_GSH = 1
     L_GSH = LDG*N

     I_VSH = I_GSH + L_GSH
     L_VSH = LDV*N

     I_GVB = I_VSH + L_VSH
     L_GVB = (LDAC*NBSIZ2) * MYNBL

     I_WRK = I_GVB + L_GVB
     L_WRK = L_WORK * NPAIRS

     MYLWRK = L_GSH + L_VSH + L_GVB + L_WRK

     ! block pointers
     J = 4 * MYNBL
     IF (J .LT. I_CL1_LEN) THEN
        J = I_CL1_LEN
     ELSE
        I = MOD(J, I_CL1_LEN)
        IF (I .NE. 0) J = J + (I_CL1_LEN - I)
     END IF

     I_BP = 1
     L_BP = J

     ! integer arrays
     J = MYNBL
     IF (J .LT. I_CL1_LEN) THEN
        J = I_CL1_LEN
     ELSE
        I = MOD(J, I_CL1_LEN)
        IF (I .NE. 0) J = J + (I_CL1_LEN - I)
     END IF

     I_NC = I_BP + L_BP
     L_NC = J

     I_IFC = I_NC + L_NC
     L_IFC = J

     I_JP = I_IFC + L_IFC
     L_JP = J

     I_LP = I_JP + L_JP
     L_LP = J

     I_IP = I_LP + L_LP
     L_IP = J

     I_IWRK = I_IP + L_IP
     L_IWRK = L_IWORK * NPAIRS

     MYLIWRK = L_BP + L_NC + L_IFC + L_JP + L_LP + L_IP + L_IWRK
  END IF

  INFO(1) = MYLWRK
  INFO(2) = MYLIWRK

  IF (LWORK .LT. MYLWRK) RETURN
  IF (LIWORK .LT. MYLIWRK) RETURN

  IF (.NOT. FAST) THEN
     WRITE (GET_IOUNIT('O'),'(A,I4,A,I11,A,I11,A)') &
          'MAX_THREADS(', MYMTHR, '), WORK(', INFO(1), '), IWORK(', INFO(2), ')'
  END IF

  IF (N .LT. MYNBL) THEN
     CALL DJAC1(FAST, M, N, G, LDG, V, LDV, MAXCYC(2), MAXTHR(2), JSTRAT(2), TOL, SIGMA,&
          WORK, LWORK, IWORK, LIWORK, NROT, INFO)
     RETURN
  END IF

  CALL MYDJAC2(FAST, M, N, G, LDG, V, LDV, MAXCYC, MAXTHR, NBSIZE, NBSIZ2, LDAC, NPAIRS, MYNBL, JSTRAT, TOL,&
       WORK(I_GSH), WORK(I_VSH), WORK(I_GVB), WORK(I_WRK), L_WORK, IWORK(I_IWRK), L_IWORK,&
       IWORK(I_BP), IWORK(I_NC), IWORK(I_IFC), IWORK(I_JP), IWORK(I_LP), IWORK(I_IP),&
       NROT, INFO)

  IF ((INFO(1) .EQ. 0) .AND. (.NOT. FAST)) THEN
     BLASNT = MAXTHR(2) * MAXTHR(3)
     !$OMP PARALLEL NUM_THREADS(MYMTHR), PRIVATE(J)
     J = BLAS_SET_NUM_THREADS(BLASNT)
     !$OMP DO
     DO J = 1, N
        SIGMA(J) = DNRM2(M, G(1,J), 1)
        CALL DSCAL(M, D_ONE / SIGMA(J), G(1,J), 1)
     END DO
     !$OMP END DO
     !$OMP END PARALLEL
  END IF

END SUBROUTINE DJAC2
