SUBROUTINE DJACV1_PARAMQ_F(STRAT, LDA, M, N, SWP, NTHR, TOL, LDB, NB, JS0, JS1, LWORK, LIWORK, INFO)
  IMPLICIT NONE

  INTEGER, INTENT(IN) :: STRAT(2), LDA, M, N, SWP(2), NTHR
  DOUBLE PRECISION, INTENT(OUT) :: TOL
  INTEGER, INTENT(OUT) :: LDB, NB, JS0(JSMLEN), JS1(JSMLEN), LWORK, LIWORK(2), INFO(2)

  INTEGER :: PIV(2,MAX(1,NTHR))
  !DIR$ ATTRIBUTES ALIGN: MALIGN_B:: PIV
!IBM* ALIGN(MALIGN_B, PIV)

  INTEGER :: NBLK, R
  !DIR$ ASSUME_ALIGNED JS0,JS1:MALIGN_B

  INFO = 0

  IF (STRAT(2) .LT. 0) THEN
     INFO(1) = -1
     INFO(2) = 2
     RETURN
  END IF
  IF ((LDA .LE. 0) .OR. (MOD(LDA,D_VEC_LEN) .NE. 0)) THEN
     INFO(1) = -2
     INFO(2) = D_VEC_LEN
     RETURN
  END IF
  IF ((M .LE. 0) .OR. (M .GT. LDA) .OR. (M .GT. N)) THEN
     INFO(1) = -3
     INFO(2) = LDA
     RETURN
  END IF
  IF ((N .LE. 0) .OR. (N .GT. LDA) .OR. (N .GT. M)) THEN
     INFO(1) = -4
     INFO(2) = M
     RETURN
  END IF
  IF (SWP(2) .LE. 0) THEN
     INFO(1) = -5
     INFO(2) = 1
     RETURN
  END IF
  IF ((NTHR .LE. 0) .OR. (NTHR .GT. MAX_TPC)) THEN
     INFO(1) = -6
     INFO(2) = MAX_TPC
     RETURN
  END IF

  NBLK = NTHR * 2
  IF (MOD(N,NBLK) .NE. 0) THEN
     INFO(1) = -6
     INFO(2) = NBLK
     RETURN
  END IF
  NB = N / NTHR
  LDB = NB
  R = MOD(LDB, D_VEC_LEN)
  IF (R .NE. 0) LDB = LDB + (D_VEC_LEN - R)
  LWORK = LDB * NB * NBLK

  IF (LWORK .GT. D_L1D) THEN
     INFO(1) = -9
     INFO(2) = D_L1D
     RETURN
  END IF

  CALL DJACV0_PARAMQ_F(STRAT(1), LDB, NB, NB, SWP(1), TOL, JS0, LIWORK(1), INFO(1))
  IF (INFO(1) .LE. 0) RETURN

  CALL JSTRAT_INIT(JS1, STRAT(2), NBLK, INFO(2))
  IF ((INFO(2) .LT. (NBLK-1)) .OR. (INFO(2) .GT. NBLK)) THEN
     INFO(2) = -1
     RETURN
  END IF

  LIWORK(2) = NBLK * (NBLK / 2)
  R = MOD(LIWORK(2), I_VEC_LEN)
  IF (R .NE. 0) LIWORK(2) = LIWORK(2) + (I_VEC_LEN - R)
  LIWORK(2) = 2 * LIWORK(2)
END SUBROUTINE DJACV1_PARAMQ_F

SUBROUTINE DJACV1_PREPARE_F
  IMPLICIT NONE
END SUBROUTINE DJACV1_PREPARE_F

SUBROUTINE DJACV1_EXECUTE_F
  IMPLICIT NONE
END SUBROUTINE DJACV1_EXECUTE_F
