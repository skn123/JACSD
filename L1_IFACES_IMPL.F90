SUBROUTINE DJACV1_PREPARE_F(STRAT, LDA, M, N, NTHR, LDB, NB, WORK0, WORK1, LWORK, IWORK0, IWORK1, LIWORK, INFO)
  USE, INTRINSIC :: ISO_C_BINDING
  IMPLICIT NONE

  INTEGER, INTENT(IN) :: STRAT(2), LDA, M, N, NTHR(2)
  DOUBLE PRECISION, INTENT(OUT) :: WORK0
  DOUBLE PRECISION, INTENT(OUT), ALLOCATABLE :: WORK1(:)
  !DIR$ ATTRIBUTES ALIGN: PAGESZ_B:: WORK1
!IBM* ALIGN(PAGESZ_B, WORK1)
  INTEGER, INTENT(OUT), ALLOCATABLE :: IWORK0(:), IWORK1(:)
  !DIR$ ATTRIBUTES ALIGN: MALIGN_B:: IWORK0, IWORK1
!IBM* ALIGN(MALIGN_B, IWORK0, IWORK1)
  INTEGER, INTENT(OUT) :: LDB(2), NB(2), LWORK(2), LIWORK(2), INFO

  INTEGER :: JS(JSMLEN), PIV(2,MAX(1,NTHR(1)))
  !DIR$ ATTRIBUTES ALIGN: MALIGN_B:: JS, PIV
!IBM* ALIGN(MALIGN_B, JS, PIV)

  INTEGER :: NBLK(2), NELEM(2), STEPS, R, MINWRK, I, J, K, L
  EXTERNAL :: DLASET

  !DIR$ ASSUME (MOD(LDA,D_VEC_LEN) .EQ. 0)

  INFO = 0

  IF (STRAT(2) .LT. 0) THEN
     INFO = -1
     RETURN
  END IF
  IF ((M .LE. 0) .OR. (M .GT. LDA) .OR. (M .GT. N)) THEN
     INFO = -2
     RETURN
  END IF
  IF ((N .LE. 0) .OR. (N .GT. LDA) .OR. (N .GT. M)) THEN
     INFO = -3
     RETURN
  END IF
  IF ((NTHR(1) .LE. 0) .OR. (NTHR(1) .GT. MAX_TPC) .OR. (NTHR(2) .LE. 0) .OR. (NTHR(2) .GT. GET_NTHR())) THEN
     INFO = -4
     RETURN
  END IF

  MINWRK = PAGESZ_B / C_SIZEOF(D_ZERO)
  IF (MOD(PAGESZ_B,C_SIZEOF(D_ZERO)) .NE. 0) THEN
     INFO = -10
     RETURN
  END IF

  NBLK(2) = NTHR(2) * 2
  IF (MOD(N,NBLK(2)) .NE. 0) THEN
     INFO = -3
     RETURN
  END IF
  NB(2) = N / NTHR(2)
  LDB(2) = NB(2)
  R = MOD(LDB(2), D_VEC_LEN)
  IF (R .NE. 0) LDB(2) = LDB(2) + (D_VEC_LEN - R)
  NELEM(2) = LDB(2) * NB(2)

  IF (NELEM(2) .GT. D_L2D) THEN
     INFO = -3
     RETURN
  END IF

  NBLK(1) = NTHR(1) * 2
  IF (MOD(NB(2),NBLK(1)) .NE. 0) THEN
     INFO = -3
     RETURN
  END IF
  NB(1) = NB(2) / NTHR(1)
  LDB(1) = NB(1)
  R = MOD(LDB(1), D_VEC_LEN)
  IF (R .NE. 0) LDB(1) = LDB(1) + (D_VEC_LEN - R)
  NELEM(1) = LDB(1) * NB(1)

  IF (NELEM(1) .GT. D_L1D) THEN
     INFO = -3
     RETURN
  END IF

  WORK0 = D_MONE
  CALL DJACV0_PREPAPRE_F(STRAT(1), LDB(1), NB(1), NB(1), WORK0, IWORK0, LIWORK(1), INFO)
  IF ((INFO .EQ. -1) .OR. (INFO .EQ. 0)) THEN
     RETURN
  ELSE IF (INFO .LT. 0) THEN
     INFO = -3
     RETURN
  END IF

  LWORK(2) = (NELEM(2) + NELEM(1) * NTHR(1)) * 2
  R = MOD(LWORK(2), MINWRK)
  IF (R .NE. 0) LWORK(2) = LWORK(2) + (MINWRK - R)
  MINWRK = LWORK(2)
  LWORK(2) = LWORK(2) * NTHR(2)

  IF (ALLOCATED(WORK1)) DEALLOCATE(WORK1)
  ALLOCATE(WORK1(LWORK(2)))

  L = 2 * NTHR(1)
  !$OMP PARALLEL NUM_THREADS(NTHR(2)) DEFAULT(SHARED) PRIVATE(I,J,K,R)
  R = BLAS_SET_NUM_THREADS(NTHR(1))
  !$OMP DO
  DO I = 1, NTHR(2)
     K = (I - 1) * MINWRK + 1
     CALL DLASET('A', LDB(2), NB(2), D_ZERO, D_ONE, WORK1(K), LDB(2))
     K = K + NELEM(2)
     CALL DLASET('A', LDB(2), NB(2), D_ZERO, D_ONE, WORK1(K), LDB(2))
     DO J = 1, L
        CALL DLASET('A', LDB(1), NB(1), D_ZERO, D_ONE, WORK1(K), LDB(1))
        K = K + NELEM(1)
     END DO
  END DO
  !$OMP END DO
  R = BLAS_SET_NUM_THREADS(R)
  !$OMP END PARALLEL

  CALL JSTRAT_INIT(JS, STRAT(2), NBLK(2), STEPS)
  IF (STEPS .LE. 0) THEN
     INFO = -1
     RETURN
  END IF

  MINWRK = STEPS * NTHR(2)
  R = MOD(MINWRK, I_VEC_LEN)
  IF (R .NE. 0) MINWRK = MINWRK + (I_VEC_LEN - R)

  LIWORK(2) = 2 * MINWRK
  IF (ALLOCATED(IWORK1)) DEALLOCATE(IWORK1)
  ALLOCATE(IWORK1(LIWORK(2)))

  R = 1
  DO I = 1, STEPS
     CALL JSTRAT_NEXT(JS, PIV, INFO)
     IF (INFO .NE. NTHR(2)) THEN
        INFO = 0
        RETURN
     END IF
     DO J = 1, NTHR(2)
        IWORK1(R) = PIV(1,J) * LDA + 1 ! P
        IWORK1(MINWRK + R) = PIV(2,J) * LDA + 1 ! Q
        R = R + 1
     END DO
  END DO

  INFO = STEPS
END SUBROUTINE DJACV1_PREPARE_F

SUBROUTINE DJACV1_EXECUTE_F
  IMPLICIT NONE
END SUBROUTINE DJACV1_EXECUTE_F
