SUBROUTINE INVJAC2(NC1,IFC1, NC2,IFC2, M,N, G,LDG, V,LDV, NBSIZ2,LDAC,&
     MAXCYC,MAXTHR,BLKTHR,JSTRAT, TOL, GB,VB, WORK,LWORK, IWORK,LIWORK, LROTP,INFOP)

  IMPLICIT NONE

  LOGICAL, PARAMETER :: MYFAST = .TRUE.

  INTEGER, INTENT(IN) :: NC1,IFC1, NC2,IFC2, M,N, LDG,LDV, NBSIZ2,LDAC, MAXCYC(2),MAXTHR(2),BLKTHR,JSTRAT(2), LWORK,LIWORK
  DOUBLE PRECISION, INTENT(INOUT) :: G(LDG,N), V(LDV,N)
  DOUBLE PRECISION, INTENT(IN) :: TOL
  DOUBLE PRECISION, INTENT(OUT) :: GB(LDAC,NBSIZ2),VB(LDAC,NBSIZ2), WORK(LWORK)
  INTEGER, INTENT(OUT) :: IWORK(LIWORK), LROTP(2), INFOP(2)

  INTEGER :: NCF, I, J
  DOUBLE PRECISION :: SIGMAP(1)

  INTEGER, INTRINSIC :: MOD
  EXTERNAL :: DLASET, DGEMM, DPOTRF, DSYRK

  !DIR$ ASSUME_ALIGNED G:MALIGN_B, V:MALIGN_B
  !DIR$ ASSUME_ALIGNED GB:MALIGN_B,VB:MALIGN_B, WORK:MALIGN_B, IWORK:MALIGN_B
  !DIR$ ASSUME (MOD(LDG,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LDV,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LDAC,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LWORK,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LIWORK,I_CL1_LEN) .EQ. 0)

  INFOP = 0
  LROTP = 0

  NCF = NC1 + NC2

  CALL DSYRK('U', 'T', NC1, M, D_ONE, G(1,IFC1), LDG, D_ZERO, GB(1, 1), LDAC)
  CALL DSYRK('U', 'T', NC2, M, D_ONE, G(1,IFC2), LDG, D_ZERO, GB(NC1+1, NC1+1), LDAC)
  CALL DGEMM('T', 'N', NC1, NC2, M, D_ONE, G(1,IFC1), LDG, G(1,IFC2), LDG, D_ZERO, GB(1, NC1+1), LDAC)

  CALL DPOTRF('U', NCF, GB, LDAC, INFOP(2))
  IF (INFOP(2) .EQ. 0) THEN
     CALL DLASET('L', NCF-1, NCF-1, D_ZERO, D_ZERO, GB(2,1), LDAC)
     IF ((NC1 .EQ. NC2) .OR. (JSTRAT(1) .LT. JSMENC)) THEN
        CALL VJAC1(MYFAST, NCF,NCF, GB,LDAC, VB,LDAC, MAXCYC,MAXTHR,BLKTHR,JSTRAT, TOL, SIGMAP,&
             WORK,LWORK, IWORK,LIWORK, LROTP,INFOP)
     ELSE! |NC1 - NC2| = 1 (==> NCF odd ==> no parallel strategy implemented)
        ! Border GB with 1 row and 1 column of zeroes, and set the last diagonal element to 1.
        CALL DLASET('A', NCF, 1, D_ZERO, D_ZERO, GB(1,NCF+1), LDAC)
        CALL DLASET('A', 1, NCF, D_ZERO, D_ZERO, GB(NCF+1,1), LDAC)
        GB(NCF+1,NCF+1) = D_ONE
        CALL VJAC1(MYFAST, NCF+1,NCF+1, GB,LDAC, VB,LDAC, MAXCYC,MAXTHR,BLKTHR,JSTRAT, TOL, SIGMAP,&
             WORK,LWORK, IWORK,LIWORK, LROTP,INFOP)
     END IF
     IF (INFOP(1) .EQ. 0) THEN
        IF (LROTP(1) .GT. 0) THEN
           DO I = 1, M, NCF
              J = MIN(NCF, (M - I) + 1)
              CALL DGEMM('N','N', J,NC1,NC2, D_ONE, G(I,IFC2), LDG, VB(NC1+1, 1), LDAC, D_ZERO, GB(1,1), LDAC)
              CALL DGEMM('N','N', J,NC1,NC1, D_ONE, G(I,IFC1), LDG, VB(1, 1), LDAC, D_ONE, GB(1,1), LDAC)
              CALL DGEMM('N','N', J,NC2,NC1, D_ONE, G(I,IFC1), LDG, VB(1, NC1+1), LDAC, D_ZERO, GB(1,NC1+1), LDAC)
              CALL DGEMM('N','N', J,NC2,NC2, D_ONE, G(I,IFC2), LDG, VB(NC1+1, NC1+1), LDAC, D_ONE, GB(1,NC1+1), LDAC)
              CALL DLACPY('A', J, NC1, GB(1,1), LDAC, G(I,IFC1), LDG)
              CALL DLACPY('A', J, NC2, GB(1,NC1+1), LDAC, G(I,IFC2), LDG)
           END DO
           DO I = 1, N, NCF
              J = MIN(NCF, (N - I) + 1)
              CALL DGEMM('N','N', J,NC1,NC2, D_ONE, V(I,IFC2), LDV, VB(NC1+1, 1), LDAC, D_ZERO, GB(1,1), LDAC)
              CALL DGEMM('N','N', J,NC1,NC1, D_ONE, V(I,IFC1), LDV, VB(1, 1), LDAC, D_ONE, GB(1,1), LDAC)
              CALL DGEMM('N','N', J,NC2,NC1, D_ONE, V(I,IFC1), LDV, VB(1, NC1+1), LDAC, D_ZERO, GB(1,NC1+1), LDAC)
              CALL DGEMM('N','N', J,NC2,NC2, D_ONE, V(I,IFC2), LDV, VB(NC1+1, NC1+1), LDAC, D_ONE, GB(1,NC1+1), LDAC)
              CALL DLACPY('A', J, NC1, GB(1,1), LDAC, V(I,IFC1), LDV)
              CALL DLACPY('A', J, NC2, GB(1,NC1+1), LDAC, V(I,IFC2), LDV)
           END DO
        END IF
     END IF
  ELSE
     INFOP(1) = 21
  END IF

END SUBROUTINE INVJAC2

SUBROUTINE MYVJAC2(FAST, M, N, G, LDG, V, LDV, MAXCYC, MAXTHR, BLKTHR, NBSIZE, NBSIZ2, LDAC, NPAIRS, NBL, JSTRAT, TOL,&
     GVB, WORK, LWORK, IWORK, LIWORK, NC, IFC, JPAIRS, LROTP, INFOP, NROT, INFO)

  IMPLICIT NONE

  LOGICAL, INTENT(IN) :: FAST
  INTEGER, INTENT(IN) :: M,N, LDG,LDV, MAXCYC(3),MAXTHR(3),BLKTHR(2), NBSIZE,NBSIZ2,LDAC, NPAIRS,NBL, JSTRAT(3), LWORK,LIWORK
  INTEGER, INTENT(OUT) :: IWORK(LIWORK,MAXTHR(1)), NC(NBL),IFC(NBL),&
       JPAIRS(2,NPAIRS),LROTP(2,MAXTHR(1)),INFOP(2,MAXTHR(1)), NROT(2),INFO(2)
  DOUBLE PRECISION, INTENT(IN) :: TOL
  DOUBLE PRECISION, INTENT(INOUT) :: G(LDG,N)
  DOUBLE PRECISION, INTENT(OUT) :: V(LDV,N)
  DOUBLE PRECISION, INTENT(OUT) :: GVB(LDAC,NBSIZ2,2,MAXTHR(1)), WORK(LWORK,MAXTHR(1))

  INTEGER :: JS(JSMLEN), LROT(2), STEPS, CYC, STP, BLASNT, PAIR, B,P,Q, I,J,K, NC1,IFC1, NC2,IFC2, U, CLK(3)

  INTEGER, INTRINSIC :: IAND, MOD
  EXTERNAL :: DLACPY, DLASET

  !DIR$ ASSUME_ALIGNED G:MALIGN_B,V:MALIGN_B, GVB:MALIGN_B, WORK:MALIGN_B,IWORK:MALIGN_B
  !DIR$ ASSUME_ALIGNED NC:MALIGN_B,IFC:MALIGN_B, JPAIRS:MALIGN_B,LROTP:MALIGN_B,INFOP:MALIGN_B
  !DIR$ ASSUME (MOD(LDG,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LDV,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LDAC,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LWORK,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LIWORK,I_CL1_LEN) .EQ. 0)

  INFO = 0
  NROT = 0

  ! STEPS = ((NBL / NPAIRS) * (NBL - 1)) / 2
  CALL JSTRAT_INIT(JS, JSTRAT(1), NBL, STEPS)
  IF (STEPS .LE. 0) THEN
     INFO(1) = 22
     INFO(2) = STEPS
     RETURN
  END IF

  IF (FAST) THEN
     U = -1
  ELSE
     U = GET_IOUNIT('O')
     IF (U .LT. 0) THEN
        INFO(1) = 23
        INFO(2) = U
        RETURN
     END IF
  END IF

  I = MOD(N, NBL)
  IF (I .EQ. 0) I = NBL
  DO J = 1, I
     NC(J) = NBSIZE
  END DO
  DO J = I+1, NBL
     NC(J) = NBSIZE - 1
  END DO

  IFC(1) = 1
  DO J = 2, NBL
     IFC(J) = IFC(J-1) + NC(J-1)
  END DO

  BLASNT = MAXTHR(2) * MAXTHR(3)
  !$OMP PARALLEL NUM_THREADS(MAXTHR(1)), PRIVATE(I,J)
  J = BLAS_SET_NUM_THREADS(BLASNT)
  !$OMP DO
  DO I = 1, NBL
     CALL DLASET('A', N, NC(I), D_ZERO, D_ZERO, V(1,IFC(I)), LDV)
     DO J = IFC(I), IFC(I)+(NC(I)-1)
        V(J,J) = D_ONE
     END DO
  END DO
  !$OMP END DO
  !$OMP END PARALLEL

  DO CYC = 1, MAXCYC(1)

     IF (.NOT. FAST) CALL TIMER_START(CLK)
     LROT = 0

     DO STP = 1, STEPS

        CALL JSTRAT_NEXT(JS, JPAIRS, J)
        IF (J .EQ. 0) THEN
           INFO(1) = 24
           INFO(2) = J
           RETURN
        END IF

        DO B = 1, BLKTHR(1)
           P = (B - 1) * MAXTHR(1) + 1
           Q = P + (MAXTHR(1) - 1)
           !$OMP PARALLEL NUM_THREADS(MAXTHR(1)), PRIVATE(PAIR,I,J,K,NC1,IFC1,NC2,IFC2)
           J = BLAS_SET_NUM_THREADS(BLASNT)
           !$OMP DO
           DO PAIR = P, Q
              I = IAND(JPAIRS(1,PAIR), JSMASK) + 1
              J = IAND(JPAIRS(2,PAIR), JSMASK) + 1
              K = (PAIR - P) + 1

              NC1 = NC(I)
              IFC1 = IFC(I)
              NC2 = NC(J)
              IFC2 = IFC(J)

              CALL INVJAC2(NC1,IFC1, NC2,IFC2, M,N, G,LDG, V,LDV, NBSIZ2,LDAC,&
                   MAXCYC(2),MAXTHR(2),BLKTHR(2),JSTRAT(2), TOL, GVB(1,1,1,K),GVB(1,1,2,K),&
                   WORK(1,K),LWORK, IWORK(1,K),LIWORK, LROTP(1,K),INFOP(1,K))

              IF (INFOP(1,K) .NE. 0) THEN
                 !$OMP CRITICAL
                 INFO(1) = INFOP(1,K)
                 INFO(2) = INFOP(2,K)
                 IF (.NOT. FAST) WRITE (UNIT=GET_IOUNIT('E'), FMT='(A,I5,A,I10,A,I10,A)') &
                      'PAIR(', PAIR, '), INFO1(', INFO(1), '), INFO2(', INFO(2), ')'
                 !$OMP END CRITICAL
              END IF
           END DO
           !$OMP END DO
           !$OMP END PARALLEL

           IF (INFO(1) .NE. 0) RETURN
           DO K = 1, MAXTHR(1)
              LROT(1) = LROT(1) + LROTP(1,K)
              LROT(2) = LROT(2) + LROTP(2,K)
           END DO
        END DO

     END DO ! STP

     NROT(1) = NROT(1) + LROT(1)
     NROT(2) = NROT(2) + LROT(2)
     IF (FAST) THEN
        IF (LROT(1) .EQ. 0) EXIT
     ELSE
        CALL TIMER_STOP(CLK)
        WRITE (UNIT=U, FMT='(A,I3,A,I19,A,I19,A)', ADVANCE='NO') &
             'CYC(',CYC, '),ALLROT(',LROT(1), '),BIGROT(',LROT(2),'), '
        CALL TIMER_PRINT(CLK)
        IF (LROT(2) .EQ. 0) EXIT
     END IF

  END DO ! CYC

  INFO(1) = 0
  INFO(2) = CYC

END SUBROUTINE MYVJAC2

SUBROUTINE VJAC2(FAST, M, N, G, LDG, V, LDV, MAXCYC, MAXTHR, BLKTHR, JSTRAT, TOL, SIGMA,&
     WORK, LWORK, IWORK, LIWORK, NROT, INFO)

  IMPLICIT NONE

  LOGICAL, INTENT(IN) :: FAST
  INTEGER, INTENT(IN) :: M, N, LDG, LDV, MAXCYC(3), MAXTHR(3), BLKTHR(2), JSTRAT(3), LWORK, LIWORK
  INTEGER, INTENT(OUT) :: IWORK(LIWORK), NROT(2), INFO(2)
  DOUBLE PRECISION, INTENT(IN) :: TOL
  DOUBLE PRECISION, INTENT(INOUT) :: G(LDG,N)
  DOUBLE PRECISION, INTENT(OUT) :: V(LDV,N), SIGMA(N), WORK(LWORK)

  INTEGER :: NPAIRS, MYNBL, NBSIZE, NBSIZ2, LDAC, MYLWRK, MYLIWRK, BLASNT, I, J
  INTEGER :: I_GVB,I_WRK, I_NC,I_IFC,I_JP,I_LP,I_IP,I_IWRK
  INTEGER :: L_GVB,L_WRK, L_NC,L_IFC,L_JP,L_LP,L_IP,L_IWRK, L_WORK,L_IWORK

  INTEGER, INTRINSIC :: MOD
  DOUBLE PRECISION, EXTERNAL :: DNRM2
  EXTERNAL :: DSCAL

  !DIR$ ASSUME_ALIGNED G:MALIGN_B,V:MALIGN_B, WORK:MALIGN_B,IWORK:MALIGN_B
  !DIR$ ASSUME (MOD(LDG,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LDV,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LWORK,D_CL1_LEN) .EQ. 0)
  !DIR$ ASSUME (MOD(LIWORK,I_CL1_LEN) .EQ. 0)

  IF (M .LT. 0) THEN
     INFO(1) = -2
     INFO(2) = M
  ELSE IF (N .LT. 0) THEN
     INFO(1) = -3
     INFO(2) = N
  ELSE IF (N .GT. M) THEN
     INFO(1) = -3
     INFO(2) = N
  ELSE IF (LDG .LT. M) THEN
     INFO(1) = -5
     INFO(2) = LDG
  ELSE IF (LDV .LT. N) THEN
     INFO(1) = -7
     INFO(2) = LDV
  ELSE IF (MAXCYC(1) .LT. 0) THEN
     INFO(1) = -8
     INFO(2) = MAXCYC(1)
  ELSE IF (MAXTHR(1) .LE. 0) THEN
     INFO(1) = -9
     INFO(2) = MAXTHR(1)
  ELSE IF (BLKTHR(1) .LE. 0) THEN
     INFO(1) = -10
     INFO(2) = BLKTHR(1)
  ELSE IF (JSTRAT(1) .LT. 0) THEN
     INFO(1) = -10
     INFO(2) = JSTRAT(1)
  ELSE IF (LWORK .LT. 0) THEN
     INFO(1) = -14
     INFO(2) = LWORK
  ELSE IF (LIWORK .LT. 0) THEN
     INFO(1) = -16
     INFO(2) = LIWORK
  ELSE
     INFO = 0
  END IF

  NROT = 0
  IF (INFO(1) .NE. 0) RETURN
  IF (N .EQ. 0) RETURN

  IF (JSTRAT(1) .LT. JSMENC) THEN
     NPAIRS = 1
  ELSE
     NPAIRS = MAXTHR(1) * BLKTHR(1)
  END IF
  MYNBL = 2 * NPAIRS

  NBSIZE = (N + (MYNBL - 1)) / MYNBL
  NBSIZ2 = 2 * NBSIZE
  LDAC = NBSIZ2
  J = MOD(LDAC, D_CL1_LEN)
  IF (J .NE. 0) LDAC = LDAC + (D_CL1_LEN - J)

  MYLWRK = 0
  MYLIWRK = 0

  IF (N .EQ. 1) THEN
     CALL VJAC1(FAST, M, N, G, LDG, V, LDV, MAXCYC(2), MAXTHR(2), BLKTHR(2), JSTRAT(2), TOL, SIGMA,&
          WORK, MYLWRK, IWORK, MYLIWRK, NROT, INFO)
     RETURN
  ELSE IF (N .LT. MYNBL) THEN
     CALL VJAC1(FAST, M,N, G, LDG, V, LDV, MAXCYC(2), MAXTHR(2), BLKTHR(2), JSTRAT(2), TOL, SIGMA,&
          WORK, MYLWRK, IWORK, MYLIWRK, NROT, INFO)
     IF (INFO(1) .LT. 0) RETURN
     IF (INFO(1) .GT. 0) MYLWRK = INFO(1)
     IF (INFO(2) .GT. 0) MYLIWRK = INFO(2)
  ELSE
     CALL VJAC1(FAST, M,N, G, LDG, V, LDV, MAXCYC(2), MAXTHR(2), BLKTHR(2), JSTRAT(2), TOL, SIGMA,&
          WORK, MYLWRK, IWORK, MYLIWRK, NROT, INFO)
     IF (INFO(1) .LT. 0) RETURN
     IF (INFO(1) .GT. 0) L_WORK = INFO(1)
     IF (INFO(2) .GT. 0) L_IWORK = INFO(2)

     I_GVB = 1
     L_GVB = 2 * (LDAC*NBSIZ2) * MAXTHR(1)

     I_WRK = I_GVB + L_GVB
     L_WRK = L_WORK * MAXTHR(1)

     MYLWRK = L_GVB + L_WRK

     ! integer arrays
     J = MYNBL
     IF (J .LT. I_CL1_LEN) THEN
        J = I_CL1_LEN
     ELSE
        I = MOD(J, I_CL1_LEN)
        IF (I .NE. 0) J = J + (I_CL1_LEN - I)
     END IF

     I_NC = 1
     L_NC = J

     I_IFC = I_NC + L_NC
     L_IFC = J

     I_JP = I_IFC + L_IFC
     L_JP = J

     J = MAXTHR(1)
     IF (J .LT. I_CL1_LEN) THEN
        J = I_CL1_LEN
     ELSE
        I = MOD(J, I_CL1_LEN)
        IF (I .NE. 0) J = J + (I_CL1_LEN - I)
     END IF

     I_LP = I_JP + L_JP
     L_LP = J

     I_IP = I_LP + L_LP
     L_IP = J

     I_IWRK = I_IP + L_IP
     L_IWRK = L_IWORK * MAXTHR(1)

     MYLIWRK = L_NC + L_IFC + L_JP + L_LP + L_IP + L_IWRK
  END IF

  INFO(1) = MYLWRK
  INFO(2) = MYLIWRK

  IF (LWORK .LT. MYLWRK) RETURN
  IF (LIWORK .LT. MYLIWRK) RETURN

  IF (.NOT. FAST) THEN
     WRITE (GET_IOUNIT('O'),'(A,I4,A,I5,A,I11,A,I11,A)') &
          'MAX_THREADS(', MAXTHR(1), '), NPAIRS(', NPAIRS, '), WORK(', INFO(1), '), IWORK(', INFO(2), ')'
  END IF

  IF (N .LT. MYNBL) THEN
     CALL VJAC1(FAST, M, N, G, LDG, V, LDV, MAXCYC(2), MAXTHR(2), BLKTHR(2), JSTRAT(2), TOL, SIGMA,&
          WORK, LWORK, IWORK, LIWORK, NROT, INFO)
     RETURN
  END IF

  CALL MYVJAC2(FAST, M, N, G, LDG, V, LDV, MAXCYC, MAXTHR, BLKTHR, NBSIZE, NBSIZ2, LDAC, NPAIRS, MYNBL, JSTRAT, TOL,&
       WORK(I_GVB), WORK(I_WRK), L_WORK, IWORK(I_IWRK), L_IWORK,&
       IWORK(I_NC), IWORK(I_IFC), IWORK(I_JP), IWORK(I_LP), IWORK(I_IP),&
       NROT, INFO)

  IF ((INFO(1) .EQ. 0) .AND. (.NOT. FAST)) THEN
     BLASNT = MAXTHR(2) * MAXTHR(3)
     !$OMP PARALLEL NUM_THREADS(MAXTHR(1)), PRIVATE(J)
     J = BLAS_SET_NUM_THREADS(BLASNT)
     !$OMP DO
     DO J = 1, N
        SIGMA(J) = DNRM2(M, G(1,J), 1)
        CALL DSCAL(M, D_ONE / SIGMA(J), G(1,J), 1)
     END DO
     !$OMP END DO
     !$OMP END PARALLEL
  END IF

END SUBROUTINE VJAC2
