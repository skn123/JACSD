PROGRAM xDGESVD

  USE CSD
  IMPLICIT NONE

  CHARACTER, PARAMETER :: JOBU = 'A', JOBVT = 'A'

  INTEGER :: M, N, T, INFO
  CHARACTER(LEN=256) :: F

  INTEGER :: LDA, LDU, LDVT, LWORK, IOU, R, CLK(3)
  DOUBLE PRECISION, ALLOCATABLE :: A(:,:), U(:,:), VT(:,:), S(:), WORK(:)
  !DIR$ ATTRIBUTES ALIGN: MALIGN_B:: A,U,VT, S, WORK
!IBM* ALIGN(MALIGN_B, A,U,VT, S, WORK)

  INTEGER, INTRINSIC :: CEILING, MIN, MOD
  EXTERNAL :: DGESVD

  CALL READCL(M, N, T, F, INFO)
  IF (INFO .NE. 0) STOP 'xDGESVD.exe M N T F'
  IF (M .LE. 0) STOP 'M <= 0'
  IF (N .LE. 0) STOP 'N <= 0'
  IF (N .GT. M) STOP 'N > M'

  IOU = GET_IOUNIT('N')
  IF (IOU .LT. 0) STOP 'IOU < 0'

  CALL BIN_OPEN(IOU, TRIM(F), 'OLD', 'READ', INFO)
  IF (INFO .NE. 0) STOP 'BIN_OPEN(.bin)'

  LDA = M
  R = MOD(LDA, D_CL1_LEN)
  IF (R .NE. 0) LDA = LDA + (D_CL1_LEN - R)
  ALLOCATE(A(LDA,N)); A = D_ZERO

  CALL BIN_READ_2D(IOU, LDA, A, M, N, INFO)
  IF (INFO .NE. 0) STOP 'BIN_READ_2D(A)'

  CALL BIN_CLOSE(IOU, INFO)
  IF (INFO .NE. 0) STOP 'BIN_CLOSE(.bin)'

  LDU = LDA
  ALLOCATE(U(LDU,M)); U = D_ZERO

  LDVT = N
  R = MOD(LDVT, D_CL1_LEN)
  IF (R .NE. 0) LDVT = LDVT + (D_CL1_LEN - R)
  ALLOCATE(VT(LDVT,N)); VT = D_ZERO

  R = MIN(M,N)
  ALLOCATE(S(R)); S = D_ZERO

  INFO = BLAS_PREPARE()
  IF (INFO .LT. 0) STOP 'BLAS_PREPARE'
  INFO = BLAS_SET_NUM_THREADS(T)

  LWORK = -1
  CALL DGESVD(JOBU, JOBVT, M, N, A, LDA, S, U, LDU, VT, LDVT, S, LWORK, INFO)
  IF (INFO .NE. 0) STOP 'DGESVD(workspace query)'
  LWORK = CEILING(S(1))
  ALLOCATE(WORK(LWORK)); WORK = D_ZERO

  CALL TIMER_START(CLK)
  CALL DGESVD(JOBU, JOBVT, M, N, A, LDA, S, U, LDU, VT, LDVT, WORK, LWORK, INFO)
  CALL TIMER_STOP(CLK)

  DEALLOCATE(WORK)

  WRITE (*,'(I5,A,I5,A,I5,A,I10,A)',ADVANCE='NO') INFO,',',M,',',N,',',LWORK,','
  CALL TIMER_PRINT(CLK)

  CALL BIN_OPEN(IOU, (TRIM(F)//'.out'), 'REPLACE', 'WRITE', INFO)
  IF (INFO .NE. 0) STOP 'BIN_OPEN(.out)'

  CALL BIN_WRITE_1D(IOU, S, R, INFO)
  DEALLOCATE(S)
  IF (INFO .NE. 0) STOP 'BIN_WRITE_1D(S)'

  CALL BIN_WRITE_2D(IOU, LDVT, VT, N, N, INFO)
  DEALLOCATE(VT)
  IF (INFO .NE. 0) STOP 'BIN_WRITE_2D(VT)'

  CALL BIN_WRITE_2D(IOU, LDU, U, M, M, INFO)
  DEALLOCATE(U)
  IF (INFO .NE. 0) STOP 'BIN_WRITE_2D(U)'

  R = IOU + 1
  CALL BIN_OPEN(R, TRIM(F), 'OLD', 'READ', INFO)
  IF (INFO .NE. 0) STOP 'BIN_OPEN[.bin]'

  CALL BIN_READ_2D(R, LDA, A, M, N, INFO)
  IF (INFO .NE. 0) STOP 'BIN_READ_2D[A]'

  CALL BIN_CLOSE(R, INFO)
  IF (INFO .NE. 0) STOP 'BIN_CLOSE[.bin]'

  CALL BIN_WRITE_2D(IOU, LDU, A, M, N, INFO)
  DEALLOCATE(A)
  IF (INFO .NE. 0) STOP 'BIN_WRITE_2D(A)'

  CALL BIN_WRITE_1I(IOU, CLK, 3, INFO)
  IF (INFO .NE. 0) STOP 'BIN_WRITE_1I(CLK)'

  CLK(1) = T
  CLK(2) = M
  CLK(3) = N
  CALL BIN_WRITE_1I(IOU, CLK, 3, INFO)
  IF (INFO .NE. 0) STOP 'BIN_WRITE_1I(TMN)'

  CALL BIN_CLOSE(IOU, INFO)
  IF (INFO .NE. 0) STOP 'BIN_CLOSE(.out)'

CONTAINS

  SUBROUTINE READCL(M, N, T, F, INFO)

    INTEGER, INTENT(OUT) :: M, N, T, INFO
    CHARACTER(LEN=*), INTENT(OUT) :: F

#ifndef USE_IBM
    INTEGER, INTRINSIC :: COMMAND_ARGUMENT_COUNT
#endif
    INTRINSIC :: GET_COMMAND_ARGUMENT

    INFO = COMMAND_ARGUMENT_COUNT()
    IF (INFO .EQ. 4) THEN
       CALL GET_COMMAND_ARGUMENT(1, F)
       READ (F,*) M

       CALL GET_COMMAND_ARGUMENT(2, F)
       READ (F,*) N

       CALL GET_COMMAND_ARGUMENT(3, F)
       READ (F,*) T

       CALL GET_COMMAND_ARGUMENT(4, F)
    END IF
    INFO = INFO - 4

  END SUBROUTINE READCL

END PROGRAM xDGESVD
