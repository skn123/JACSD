PROGRAM xDJAC1

  USE CSD
  IMPLICIT NONE

  LOGICAL, PARAMETER :: FAST = .FALSE.
  INTEGER, PARAMETER :: MXCYC1 = HUGE(0)
  DOUBLE PRECISION, PARAMETER :: TOL = D_ZERO

  INTEGER :: M, N
  CHARACTER(LEN=256) :: F
  INTEGER :: LDG, LDV, MAXCYC(2), MAXTHR(2), JSTRAT(2), LWORK, LIWORK
  INTEGER :: R, IOU, NROT(2), CLK(3), INFO(2), IWORK1(I_CL1_LEN)
  DOUBLE PRECISION :: WORK1(D_CL1_LEN)

  DOUBLE PRECISION, ALLOCATABLE :: G(:,:), V(:,:), SIGMA(:), WORK(:)
  INTEGER, ALLOCATABLE :: IWORK(:)
  !DIR$ ATTRIBUTES ALIGN: MALIGN_B:: G,V, SIGMA, WORK,IWORK, WORK1,IWORK1

  INTEGER, INTRINSIC :: MOD

  CALL READCL(M, N, JSTRAT(2), MAXCYC(2), MAXTHR(2), JSTRAT(1), MAXTHR(1), F, INFO(2))
  IF (INFO(2) .NE. 0) STOP 'xDJAC1.exe M N J0 C0 T0 J1 T1 F'
  IF (M .LE. 0) STOP 'M <= 0'
  IF (N .LE. 0) STOP 'N <= 0'
  IF (N .GT. M) STOP 'N > M'

  MAXCYC(1) = MXCYC1

  IOU = GET_IOUNIT('N')
  IF (IOU .LT. 0) STOP 'IOU < 0'

  CALL BIN_OPEN(IOU, TRIM(F), 'OLD', 'READ', INFO(2))
  IF (INFO(2) .NE. 0) STOP 'BIN_OPEN(.bin)'

  LDG = M
  R = MOD(LDG, D_CL1_LEN)
  IF (R .NE. 0) LDG = LDG + (D_CL1_LEN - R)

  ALLOCATE(G(LDG,N))

  CALL BIN_READ_2D(IOU, LDG, G, M, N, INFO(2))
  IF (INFO(2) .NE. 0) STOP 'BIN_READ_2D(G)'

  CALL BIN_CLOSE(IOU, INFO(2))
  IF (INFO(2) .NE. 0) STOP 'BIN_CLOSE(.bin)'

  LDV = N
  R = MOD(LDV, D_CL1_LEN)
  IF (R .NE. 0) LDV = LDV + (D_CL1_LEN - R)

  ALLOCATE(V(LDV,N))
  ALLOCATE(SIGMA(N))

  INFO(2) = BLAS_PREPARE()
  IF (INFO(2) .NE. 0) STOP 'BLAS_PREPARE'

  LWORK = 0
  LIWORK = 0
  CALL DJAC1(FAST, M, N, G, LDG, V, LDV, MAXCYC, MAXTHR, JSTRAT, TOL, SIGMA,&
       WORK1, LWORK, IWORK1, LIWORK, NROT, INFO)
  IF (INFO(1) .LT. 0) STOP 'DJAC1(workspace query)'
  IF (INFO(1) .GT. 0) THEN
     LWORK = INFO(1)
     ALLOCATE(WORK(LWORK))
  END IF
  IF (INFO(2) .GT. 0) THEN
     LIWORK = INFO(2)
     ALLOCATE(IWORK(LIWORK))
  END IF

  CALL TIMER_START(CLK)
  CALL DJAC1(FAST, M, N, G, LDG, V, LDV, MAXCYC, MAXTHR, JSTRAT, TOL, SIGMA,&
       WORK, LWORK, IWORK, LIWORK, NROT, INFO)
  CALL TIMER_STOP(CLK)

  IF (LIWORK .GT. 0) DEALLOCATE(IWORK)
  IF (LWORK .GT. 0) DEALLOCATE(WORK)

  WRITE (*,'(I3,A,I3,A,I4,A,I4,A,I10,A,I10,A)',ADVANCE='NO') INFO(1),',',INFO(2), ',',M,',',N,',', NROT(1),',',NROT(2), ','
  CALL TIMER_PRINT(CLK)

  CALL BIN_OPEN(IOU, (TRIM(F)//'.out'), 'REPLACE', 'WRITE', INFO(2))
  IF (INFO(2) .NE. 0) STOP 'BIN_OPEN(.out)'

  CALL BIN_WRITE_1D(IOU, SIGMA, N, INFO(2))
  DEALLOCATE(SIGMA)
  IF (INFO(2) .NE. 0) STOP 'BIN_WRITE_1D(SIGMA)'

  CALL BIN_WRITE_2D(IOU, LDV, V, N, N, INFO(2))
  DEALLOCATE(V)
  IF (INFO(2) .NE. 0) STOP 'BIN_WRITE_2D(V)'

  CALL BIN_WRITE_2D(IOU, LDG, G, M, N, INFO(2))
  DEALLOCATE(G)
  IF (INFO(2) .NE. 0) STOP 'BIN_WRITE_2D(G)'

  CALL BIN_CLOSE(IOU, INFO(2))
  IF (INFO(2) .NE. 0) STOP 'BIN_CLOSE(.out)'

CONTAINS

  SUBROUTINE READCL(M, N, J0, C0, T0, J1, T1, F, INFO)

    INTEGER, INTENT(OUT) :: M, N, J0, C0, T0, J1, T1, INFO
    CHARACTER(LEN=*), INTENT(OUT) :: F

#ifndef USE_IBM
    INTEGER, INTRINSIC :: COMMAND_ARGUMENT_COUNT
#endif
    INTRINSIC :: GET_COMMAND_ARGUMENT

    INFO = COMMAND_ARGUMENT_COUNT()
    IF (INFO .EQ. 8) THEN
       CALL GET_COMMAND_ARGUMENT(1, F)
       READ (F,*) M

       CALL GET_COMMAND_ARGUMENT(2, F)
       READ (F,*) N

       CALL GET_COMMAND_ARGUMENT(3, F)
       READ (F,*) J0

       CALL GET_COMMAND_ARGUMENT(4, F)
       READ (F,*) C0

       CALL GET_COMMAND_ARGUMENT(5, F)
       READ (F,*) T0

       CALL GET_COMMAND_ARGUMENT(6, F)
       READ (F,*) J1

       CALL GET_COMMAND_ARGUMENT(7, F)
       READ (F,*) T1

       CALL GET_COMMAND_ARGUMENT(8, F)
    END IF
    INFO = INFO - 8

  END SUBROUTINE READCL

END PROGRAM xDJAC1
