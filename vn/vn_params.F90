! intended for inclusion with #include preprocessing directive
  INTEGER, PARAMETER :: LWP = KIND(.FALSE.)
  INTEGER, PARAMETER :: LCSIZB = C_SIZEOF(.FALSE.)

  INTEGER, PARAMETER :: IWP = KIND(0)
  INTEGER, PARAMETER :: ICSIZB = C_SIZEOF(0)

#ifdef KIND_SINGLE
  INTEGER, PARAMETER :: SWP = KIND_SINGLE
#else
  INTEGER, PARAMETER :: SWP = KIND(0E0)
#endif
  INTEGER, PARAMETER :: SCSIZB = C_SIZEOF(0E0_SWP)

#ifdef KIND_DOUBLE
  INTEGER, PARAMETER :: DWP = KIND_DOUBLE
#else
  INTEGER, PARAMETER :: DWP = KIND(0D0)
#endif
  INTEGER, PARAMETER :: DCSIZB = C_SIZEOF(0E0_DWP)

#ifdef KIND_FILE
  INTEGER, PARAMETER :: FWP = KIND_FILE
#else
  INTEGER, PARAMETER :: FWP = DWP
#endif

  REAL(KIND=SWP), PARAMETER :: S_ZERO =  0.0_SWP
  REAL(KIND=SWP), PARAMETER :: S_MZERO= -0.0_SWP
  REAL(KIND=SWP), PARAMETER :: S_ONE  =  1.0_SWP
  REAL(KIND=SWP), PARAMETER :: S_MONE = -1.0_SWP
  REAL(KIND=SWP), PARAMETER :: S_TWO  =  2.0_SWP
  REAL(KIND=SWP), PARAMETER :: S_MTWO = -2.0_SWP

  COMPLEX(KIND=SWP), PARAMETER :: C_ZERO  = (S_ZERO, S_ZERO)
  COMPLEX(KIND=SWP), PARAMETER :: C_ONE   = (S_ONE , S_ZERO)
  COMPLEX(KIND=SWP), PARAMETER :: C_MONE  = (S_MONE, S_ZERO)
  COMPLEX(KIND=SWP), PARAMETER :: C_IONE  = (S_ZERO, S_ONE )
  COMPLEX(KIND=SWP), PARAMETER :: C_MIONE = (S_ZERO, S_MONE)

  REAL(KIND=DWP), PARAMETER :: D_ZERO =  0.0_DWP
  REAL(KIND=DWP), PARAMETER :: D_MZERO= -0.0_DWP
  REAL(KIND=DWP), PARAMETER :: D_ONE  =  1.0_DWP
  REAL(KIND=DWP), PARAMETER :: D_MONE = -1.0_DWP
  REAL(KIND=DWP), PARAMETER :: D_TWO  =  2.0_DWP
  REAL(KIND=DWP), PARAMETER :: D_MTWO = -2.0_DWP

  COMPLEX(KIND=DWP), PARAMETER :: Z_ZERO  = (D_ZERO, D_ZERO)
  COMPLEX(KIND=DWP), PARAMETER :: Z_ONE   = (D_ONE , D_ZERO)
  COMPLEX(KIND=DWP), PARAMETER :: Z_MONE  = (D_MONE, D_ZERO)
  COMPLEX(KIND=DWP), PARAMETER :: Z_IONE  = (D_ZERO, D_ONE )
  COMPLEX(KIND=DWP), PARAMETER :: Z_MIONE = (D_ZERO, D_MONE)

  REAL(KIND=SWP), PARAMETER :: S_EPS = EPSILON(S_ONE)
  REAL(KIND=DWP), PARAMETER :: D_EPS = EPSILON(D_ONE)

  ! Max SIMD vector length in bytes.
  ! Valid for the Intel AVX-512, otherwise smaller (but >= 16 B).
#ifdef SIMD_VEC_LEN_B
  INTEGER, PARAMETER :: SIMDLB = MAX(SIMD_VEC_LEN_B, 16)
#else
  INTEGER, PARAMETER :: SIMDLB = 64
#endif

  INTEGER, PARAMETER :: LSIMDL = SIMDLB / LCSIZB
  INTEGER, PARAMETER :: ISIMDL = SIMDLB / ICSIZB
  INTEGER, PARAMETER :: SSIMDL = SIMDLB / SCSIZB !+ MOD(SCSIZB,4)*3
  INTEGER, PARAMETER :: DSIMDL = SIMDLB / DCSIZB !+ MOD(DCSIZB,4)*3
  INTEGER, PARAMETER :: CSIMDL = SSIMDL / 2
  INTEGER, PARAMETER :: ZSIMDL = DSIMDL / 2

  ! Cache line size in bytes.
  ! Valid for the Intel CPUs, needs changing for POWER e.g. (128 B).
#ifdef CACHE_LINE_SIZE_B
  INTEGER, PARAMETER :: CLSIZB = MAX(CACHE_LINE_SIZE_B, 16)
#else
  INTEGER, PARAMETER :: CLSIZB = 64
#endif

  ! Memory page size in bytes (assumed to be a multiple of the cache line size).
  ! A default for the Intel CPUs is used, needs changing for the other architectures.
#ifdef PAGE_SIZE_B
  INTEGER, PARAMETER :: PGSIZB = MAX(PAGE_SIZE_B, 4096)
#else
  INTEGER, PARAMETER :: PGSIZB = 4096
#endif

  ! Alignment in bytes = max(cache line size, vector length)
  INTEGER, PARAMETER :: ALIGNB = MAX(CLSIZB, SIMDLB)

  INTEGER, PARAMETER :: LALIGN = ALIGNB / LCSIZB
  INTEGER, PARAMETER :: IALIGN = ALIGNB / ICSIZB
  INTEGER, PARAMETER :: SALIGN = ALIGNB / SCSIZB !+ MOD(SCSIZB,4)*3
  INTEGER, PARAMETER :: DALIGN = ALIGNB / DCSIZB !+ MOD(DCSIZB,4)*3
  INTEGER, PARAMETER :: CALIGN = SALIGN / 2
  INTEGER, PARAMETER :: ZALIGN = DALIGN / 2
