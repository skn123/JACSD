PROGRAM SVALSERR
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: OUTPUT_UNIT, ERROR_UNIT
  USE BIO
  IMPLICIT NONE

  INTEGER, PARAMETER :: WP = QX_WP
  REAL(KIND=WP), PARAMETER :: Q_ZERO = 0.0_WP, Q_ONE = 1.0_WP

  INTEGER, PARAMETER :: FNL = 252
  CHARACTER(LEN=2), PARAMETER :: ACT = 'RO'

  CHARACTER(LEN=FNL) :: FTRUE, FCOMP
  REAL(KIND=WP) :: MINAE, MAXAE, AVGAE, MINRE, MAXRE, AVGRE
  INTEGER :: N, INFO, U

  REAL(KIND=WP), ALLOCATABLE :: T(:), C(:)
  DOUBLE PRECISION, ALLOCATABLE :: D(:)

  CALL READCL(N, FTRUE, FCOMP, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I2,A)',ADVANCE='NO') INFO, ' '
     FLUSH(ERROR_UNIT)
     ERROR STOP 'READCL'
  END IF

  ALLOCATE(T(N))
  ALLOCATE(C(N))
  ALLOCATE(D(N))

  WRITE (OUTPUT_UNIT,'(A)') '"MINAE","MAXAE","AVGAE","MINRE","MAXRE","AVGRE"'
  FLUSH(OUTPUT_UNIT)

  U = -1
  CALL BIO_OPEN(U, TRIM(FTRUE), ACT, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I11)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' BIO_OPEN(FTRUE)'
  END IF
  CALL BIO_READ_D1(U, N, D, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I11)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' BIO_READ_D1(FTRUE)'
  END IF
  CALL BIO_CLOSE(U, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I11)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' BIO_CLOSE(FTRUE)'
  END IF
  DO INFO = 1, N
     T(INFO) = D(INFO)
  END DO
  DEALLOCATE(D)
  CALL QCSORT(N, T)

  U = -1
  CALL BIO_OPEN(U, TRIM(FCOMP), ACT, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I11)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' BIO_OPEN(FCOMP)'
  END IF
  CALL BIO_READ_Q1(U, N, C, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I11)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' BIO_READ_Q1(FCOMP)'
  END IF
  CALL BIO_CLOSE(U, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I11)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' BIO_CLOSE(FCOMP)'
  END IF
  CALL QCSORT(N, C)

  CALL ERRSTATS(N, T, C, MINAE, MAXAE, AVGAE, MINRE, MAXRE, AVGRE, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I2)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' ERRSTATS'
  END IF
  WRITE (OUTPUT_UNIT,'(5(ES25.17E3,A),ES25.17E3)') MINAE,',',MAXAE,',',AVGAE,',',MINRE,',',MAXRE,',',AVGRE
  FLUSH(OUTPUT_UNIT)

  DEALLOCATE(C)
  DEALLOCATE(T)

CONTAINS

  FUNCTION QCCMP(A, B) BIND(C)
    USE, INTRINSIC :: ISO_C_BINDING
    IMPLICIT NONE
    TYPE(c_ptr), INTENT(IN), VALUE :: A, B
    INTEGER(KIND=c_int) :: QCCMP

    REAL(KIND=WP), POINTER :: PA, PB

    CALL C_F_POINTER(A, PA)
    CALL C_F_POINTER(B, PB)
    IF (PA .LT. PB) THEN
       QCCMP = -1_c_int
    ELSE IF (PB .LT. PA) THEN
       QCCMP = 1_c_int
    ELSE ! =
       QCCMP = 0_c_int
    END IF
  END FUNCTION QCCMP

  SUBROUTINE QCSORT(N, A)
    USE, INTRINSIC :: ISO_C_BINDING
    IMPLICIT NONE

    INTERFACE
       RECURSIVE SUBROUTINE CQSORT(A, N, SZ, CMP) BIND(C,NAME='qsort')
         USE, INTRINSIC :: ISO_C_BINDING
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: A
         INTEGER(KIND=c_size_t), INTENT(IN), VALUE :: N, SZ
         TYPE(c_funptr), INTENT(IN), VALUE :: CMP
       END SUBROUTINE CQSORT
    END INTERFACE

    INTEGER, INTENT(IN) :: N
    REAL(KIND=WP), INTENT(INOUT) :: A(N)

    CALL CQSORT(C_LOC(A), INT(N,c_size_t), INT(WP,c_size_t), C_FUNLOC(QCCMP))
  END SUBROUTINE QCSORT

  PURE SUBROUTINE ERRSTATS(N, T, C, MINAE, MAXAE, AVGAE, MINRE, MAXRE, AVGRE, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: N
    REAL(KIND=WP), INTENT(IN) :: T(N), C(N)
    REAL(KIND=WP), INTENT(OUT) :: MINAE, MAXAE, AVGAE, MINRE, MAXRE, AVGRE
    INTEGER, INTENT(OUT) :: INFO

    REAL(KIND=WP) :: AE, RE, ONE_N
    INTEGER :: I

    IF (N .LT. 0) THEN
       INFO = -1
    ELSE ! all OK
       INFO = 0
    END IF
    IF (INFO .NE. 0) RETURN

    MINAE = Q_ZERO
    MAXAE = Q_ZERO
    AVGAE = Q_ZERO

    MINRE = Q_ZERO
    MAXRE = Q_ZERO
    AVGRE = Q_ZERO

    IF (N .EQ. 0) RETURN

    ONE_N = Q_ONE / N

    DO I = 1, N
       AE = ABS(T(I) - C(I))
       IF (AE .LT. MINAE) MINAE = AE
       IF (AE .GT. MAXAE) MAXAE = AE
       AVGAE = AVGAE + AE * ONE_N

       RE = AE / ABS(T(I))
       IF (.NOT. (RE .EQ. RE)) RE = Q_ZERO
       IF (RE .LT. MINRE) MINRE = RE
       IF (RE .GT. MAXRE) MAXRE = RE
       AVGRE = AVGRE + RE * ONE_N
    END DO
  END SUBROUTINE ERRSTATS

  SUBROUTINE READCL(N, FTRUE, FCOMP, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(OUT) :: N, INFO
    CHARACTER(LEN=*), INTENT(OUT) :: FTRUE, FCOMP

    CHARACTER(LEN=FNL) :: ARG
    INTEGER :: TMP

    INFO = 0
    IF (COMMAND_ARGUMENT_COUNT() .NE. 3) ERROR STOP 'svalerr.exe N FTRUE FCOMP'

    CALL GET_COMMAND_ARGUMENT(1, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -1
       RETURN
    END IF
    READ (ARG,*) N
    IF (N .LE. 0) THEN
       INFO = 1
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(2, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -2
       RETURN
    END IF
    FTRUE = TRIM(ARG)
    IF (LEN_TRIM(FTRUE) .LE. 0) THEN
       INFO = 2
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(3, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -3
       RETURN
    END IF
    FCOMP = TRIM(ARG)
    IF (LEN_TRIM(FCOMP) .LE. 0) THEN
       INFO = 3
       RETURN
    END IF
  END SUBROUTINE READCL

END PROGRAM SVALSERR
