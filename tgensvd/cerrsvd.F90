PROGRAM CERRSVD
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: OUTPUT_UNIT, ERROR_UNIT
  USE BIO
  IMPLICIT NONE

  INTEGER, PARAMETER :: WP = QX_WP
  ! Max file name length.
  INTEGER, PARAMETER :: FNL = 252
  CHARACTER(LEN=2), PARAMETER :: ACT = 'RO'
  REAL(KIND=WP), PARAMETER :: Q_ZERO = 0.0_WP

  COMPLEX, ALLOCATABLE :: A(:,:)
  COMPLEX(KIND=WP), ALLOCATABLE :: xG(:,:), xU(:,:), xV(:,:)
  REAL(KIND=WP), ALLOCATABLE :: xS(:)

  CHARACTER(LEN=FNL) :: FNG, FNU, FNS, FNV
  INTEGER :: M, N, U, I, J, INFO
  REAL(KIND=WP) :: GNF, RNF

  CALL READCL(M, N, FNG, FNU, FNS, FNV, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I2)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' READCL'
  END IF

  ALLOCATE(A(M,N))

  U = -1
  CALL BIO_OPEN(U, TRIM(FNG), ACT, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I11)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' BIO_OPEN(FNG)'
  END IF
  CALL BIO_READ_C2(U, M, N, A, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I11)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' BIO_READ_C2(FNG)'
  END IF
  CALL BIO_CLOSE(U, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I11)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' BIO_CLOSE(FNG)'
  END IF
  ALLOCATE(xG(M,N))
#ifndef NDEBUG
  WRITE (OUTPUT_UNIT,'(3A)',ADVANCE='NO') '|| ', TRIM(FNG), ' ||_F = '
  FLUSH(OUTPUT_UNIT)
#endif
  GNF = Q_ZERO
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I,J) REDUCTION(+:GNF)
  DO J = 1, N
     DO I = 1, M
        xG(I,J) = A(I,J)
        GNF = GNF + REAL(xG(I,J))*REAL(xG(I,J)) + AIMAG(xG(I,J))*AIMAG(xG(I,J))
     END DO
  END DO
  !$OMP END PARALLEL DO
  GNF = SQRT(GNF)
#ifndef NDEBUG
  WRITE (OUTPUT_UNIT,1) GNF
  FLUSH(OUTPUT_UNIT)
#endif

  U = -1
  CALL BIO_OPEN(U, TRIM(FNU), ACT, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I11)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' BIO_OPEN(FNU)'
  END IF
  CALL BIO_READ_C2(U, M, N, A, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I11)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' BIO_READ_C2(FNU)'
  END IF
  CALL BIO_CLOSE(U, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I11)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' BIO_CLOSE(FNU)'
  END IF
  ALLOCATE(xU(M,N))
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I,J)
  DO J = 1, N
     DO I = 1, M
        xU(I,J) = A(I,J)
     END DO
  END DO
  !$OMP END PARALLEL DO

  DEALLOCATE(A)
  ALLOCATE(A(N,N))

  U = -1
  CALL BIO_OPEN(U, TRIM(FNV), ACT, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I11)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' BIO_OPEN(FNV)'
  END IF
  CALL BIO_READ_C2(U, N, N, A, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I11)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' BIO_READ_C2(FNV)'
  END IF
  CALL BIO_CLOSE(U, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I11)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' BIO_CLOSE(FNV)'
  END IF
  ALLOCATE(xV(N,N))
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I,J)
  DO J = 1, N
     DO I = 1, N
        xV(I,J) = CONJG(A(J,I))
     END DO
  END DO
  !$OMP END PARALLEL DO

  DEALLOCATE(A)
  ALLOCATE(xS(N))

  U = -1
  CALL BIO_OPEN(U, TRIM(FNS), ACT, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I11)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' BIO_OPEN(FNS)'
  END IF
  CALL BIO_READ_Q1(U, N, xS, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I11)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' BIO_READ_Q1(FNS)'
  END IF
  CALL BIO_CLOSE(U, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(I11)',ADVANCE='NO') INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP ' BIO_CLOSE(FNS)'
  END IF
  !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I,J)
  DO J = 1, N
     DO I = 1, N
        xU(I,J) = xU(I,J) * xS(J)
     END DO
  END DO
  !$OMP END PARALLEL DO
  DEALLOCATE(xS)

#ifndef NDEBUG
  WRITE (OUTPUT_UNIT,'(A)',ADVANCE='NO') '|| G - (U * S) * V^H ||_F / || G ||_F = '
  FLUSH(OUTPUT_UNIT)
#endif
  RNF = PXGEMM(M, N, N, xU, M, xV, N, xG, M)
  IF (GNF .EQ. Q_ZERO) THEN
     ! Inf if RNF <> 0, else 0
     IF (RNF .NE. Q_ZERO) RNF = RNF / GNF
  ELSE ! GNF <> 0
     RNF = RNF / GNF
  END IF
  WRITE (OUTPUT_UNIT,1) RNF
  FLUSH(OUTPUT_UNIT)

  DEALLOCATE(xV)
  DEALLOCATE(xU)
  DEALLOCATE(xG)

1 FORMAT(ES24.17E3)

CONTAINS

  REAL(KIND=WP) FUNCTION PXGEMM(M, N, K, A, LDA, B, LDB, C, LDC)
    IMPLICIT NONE

    INTEGER, INTENT(IN) :: M, N, K, LDA, LDB, LDC
    COMPLEX(KIND=WP), INTENT(IN) :: A(LDA,K), B(LDB,N)
    COMPLEX(KIND=WP), INTENT(INOUT) :: C(LDC,N)

    REAL(KIND=WP) :: RE, IM, CNF
    INTEGER :: I, J, L

    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I,J,L)
    DO J = 1, N
       DO L = 1, K
          !DIR$ VECTOR ALWAYS
          DO I = 1, M
             C(I,J) = C(I,J) - A(I,L) * B(L,J)
          END DO
       END DO
    END DO
    !$OMP END PARALLEL DO

    CNF = Q_ZERO
    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I,J) REDUCTION(+:CNF)
    DO J = 1, N
       DO I = 1, M
          CNF = CNF + REAL(C(I,J))*REAL(C(I,J)) + AIMAG(C(I,J))*AIMAG(C(I,J))
       END DO
    END DO
    !$OMP END PARALLEL DO

    PXGEMM = SQRT(CNF)
  END FUNCTION PXGEMM

  SUBROUTINE READCL(M, N, FNG, FNU, FNS, FNV, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(OUT) :: M, N, INFO
    CHARACTER(LEN=*), INTENT(OUT) :: FNG, FNU, FNS, FNV

    CHARACTER(LEN=FNL) :: ARG
    INTEGER :: TMP

    INFO = 0
    IF (COMMAND_ARGUMENT_COUNT() .NE. 6) ERROR STOP 'cerrsvd.exe M N FNG FNU FNS FNV'

    CALL GET_COMMAND_ARGUMENT(1, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -1
       RETURN
    END IF
    READ (ARG,*) M
    IF (M .LE. 0) THEN
       INFO = 1
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(2, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -2
       RETURN
    END IF
    READ (ARG,*) N
    IF (N .LE. 0) THEN
       INFO = 2
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(3, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -3
       RETURN
    END IF
    FNG = TRIM(ARG)
    IF (LEN_TRIM(FNG) .LE. 0) THEN
       INFO = 3
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(4, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -4
       RETURN
    END IF
    FNU = TRIM(ARG)
    IF (LEN_TRIM(FNU) .LE. 0) THEN
       INFO = 4
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(5, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -5
       RETURN
    END IF
    FNS = TRIM(ARG)
    IF (LEN_TRIM(FNS) .LE. 0) THEN
       INFO = 5
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(6, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -6
       RETURN
    END IF
    FNV = TRIM(ARG)
    IF (LEN_TRIM(FNV) .LE. 0) THEN
       INFO = 6
       RETURN
    END IF
  END SUBROUTINE READCL
END PROGRAM CERRSVD
