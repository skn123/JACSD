MODULE DATGEN
  USE SEED
  IMPLICIT NONE

  INTEGER, PARAMETER, PRIVATE :: WP = QX_WP
  REAL(KIND=WP), PARAMETER, PRIVATE :: Q_ZERO = 0.0_WP, Q_ONE = 1.0_WP
  COMPLEX(KIND=WP), PARAMETER, PRIVATE :: X_ZERO = (Q_ZERO, Q_ZERO), X_ONE = (Q_ONE, Q_ZERO)

CONTAINS

  SUBROUTINE SGENDAT(M, N, ISEED, SS, QG, SG, QWORK, INFO)
    IMPLICIT NONE

    INTEGER, INTENT(IN) :: M, N, ISEED(4)
    REAL, INTENT(IN) :: SS(N)
    REAL, INTENT(OUT) :: SG(M,N)
    REAL(KIND=WP), INTENT(OUT) :: QG(M,N), QWORK(3*M)
    INTEGER, INTENT(OUT) :: INFO

    INTEGER :: P, Q
    EXTERNAL :: QLAROR

    INFO = 0

    IF (M .LT. 0) THEN
       INFO = -1
       RETURN
    END IF
    IF ((N .LT. 0) .OR. (N .GT. M)) THEN
       INFO = -2
       RETURN
    END IF
    CALL SEEDOK(ISEED, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -3
       RETURN
    END IF

    !$OMP PARALLEL DO DEFAULT(NONE) SHARED(M,N,QG,SS) PRIVATE(P,Q)
    DO Q = 1, N
       DO P = 1, Q-1
          QG(P,Q) = Q_ZERO
       END DO
       QG(Q,Q) = SS(Q)
       DO P = Q+1, M
          QG(P,Q) = Q_ZERO
       END DO
    END DO
    !$OMP END PARALLEL DO

    CALL QLAROR('L', 'N', M, N, QG, M, ISEED, QWORK, INFO)
    IF (INFO .NE. 0) RETURN

    CALL QLAROR('R', 'N', M, N, QG, M, ISEED, QWORK, INFO)
    IF (INFO .NE. 0) RETURN

    !$OMP PARALLEL DO DEFAULT(NONE) SHARED(M,N,QG,SG) PRIVATE(P,Q)
    DO Q = 1, N
       DO P = 1, M
          SG(P,Q) = REAL(QG(P,Q))
       END DO
    END DO
    !$OMP END PARALLEL DO
  END SUBROUTINE SGENDAT

  SUBROUTINE DGENDAT(M, N, ISEED, DS, QG, DG, QWORK, INFO)
    IMPLICIT NONE

    INTEGER, INTENT(IN) :: M, N, ISEED(4)
    DOUBLE PRECISION, INTENT(IN) :: DS(N)
    DOUBLE PRECISION, INTENT(OUT) :: DG(M,N)
    REAL(KIND=WP), INTENT(OUT) :: QG(M,N), QWORK(3*M)
    INTEGER, INTENT(OUT) :: INFO

    INTEGER :: P, Q
    EXTERNAL :: QLAROR

    INFO = 0

    IF (M .LT. 0) THEN
       INFO = -1
       RETURN
    END IF
    IF ((N .LT. 0) .OR. (N .GT. M)) THEN
       INFO = -2
       RETURN
    END IF
    CALL SEEDOK(ISEED, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -3
       RETURN
    END IF

    !$OMP PARALLEL DO DEFAULT(NONE) SHARED(M,N,QG,DS) PRIVATE(P,Q)
    DO Q = 1, N
       DO P = 1, Q-1
          QG(P,Q) = Q_ZERO
       END DO
       QG(Q,Q) = DS(Q)
       DO P = Q+1, M
          QG(P,Q) = Q_ZERO
       END DO
    END DO
    !$OMP END PARALLEL DO

    CALL QLAROR('L', 'N', M, N, QG, M, ISEED, QWORK, INFO)
    IF (INFO .NE. 0) RETURN

    CALL QLAROR('R', 'N', M, N, QG, M, ISEED, QWORK, INFO)
    IF (INFO .NE. 0) RETURN

    !$OMP PARALLEL DO DEFAULT(NONE) SHARED(M,N,QG,DG) PRIVATE(P,Q)
    DO Q = 1, N
       DO P = 1, M
          DG(P,Q) = DBLE(QG(P,Q))
       END DO
    END DO
    !$OMP END PARALLEL DO
  END SUBROUTINE DGENDAT

  SUBROUTINE CGENDAT(M, N, ISEED, SS, XG, CG, XWORK, INFO)
    IMPLICIT NONE

    INTEGER, INTENT(IN) :: M, N, ISEED(4)
    REAL, INTENT(IN) :: SS(N)
    COMPLEX, INTENT(OUT) :: CG(M,N)
    COMPLEX(KIND=WP), INTENT(OUT) :: XG(M,N), XWORK(3*M)
    INTEGER, INTENT(OUT) :: INFO

    INTEGER :: P, Q
    EXTERNAL :: XLAROR

    INFO = 0

    IF (M .LT. 0) THEN
       INFO = -1
       RETURN
    END IF
    IF ((N .LT. 0) .OR. (N .GT. M)) THEN
       INFO = -2
       RETURN
    END IF
    CALL SEEDOK(ISEED, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -3
       RETURN
    END IF

    !$OMP PARALLEL DO DEFAULT(NONE) SHARED(M,N,XG,SS) PRIVATE(P,Q)
    DO Q = 1, N
       DO P = 1, Q-1
          XG(P,Q) = X_ZERO
       END DO
       XG(Q,Q) = SS(Q)
       DO P = Q+1, M
          XG(P,Q) = X_ZERO
       END DO
    END DO
    !$OMP END PARALLEL DO

    CALL XLAROR('L', 'N', M, N, XG, M, ISEED, XWORK, INFO)
    IF (INFO .NE. 0) RETURN

    CALL XLAROR('R', 'N', M, N, XG, M, ISEED, XWORK, INFO)
    IF (INFO .NE. 0) RETURN

    !$OMP PARALLEL DO DEFAULT(NONE) SHARED(M,N,XG,CG) PRIVATE(P,Q)
    DO Q = 1, N
       DO P = 1, M
          CG(P,Q) = CMPLX(REAL(REAL(XG(P,Q))), REAL(AIMAG(XG(P,Q))))
       END DO
    END DO
    !$OMP END PARALLEL DO
  END SUBROUTINE CGENDAT

  SUBROUTINE ZGENDAT(M, N, ISEED, DS, XG, ZG, XWORK, INFO)
    IMPLICIT NONE

    INTEGER, INTENT(IN) :: M, N, ISEED(4)
    DOUBLE PRECISION, INTENT(IN) :: DS(N)
    DOUBLE COMPLEX, INTENT(OUT) :: ZG(M,N)
    COMPLEX(KIND=WP), INTENT(OUT) :: XG(M,N), XWORK(3*M)
    INTEGER, INTENT(OUT) :: INFO

    INTEGER :: P, Q
    EXTERNAL :: XLAROR

    INFO = 0

    IF (M .LT. 0) THEN
       INFO = -1
       RETURN
    END IF
    IF ((N .LT. 0) .OR. (N .GT. M)) THEN
       INFO = -2
       RETURN
    END IF
    CALL SEEDOK(ISEED, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -3
       RETURN
    END IF

    !$OMP PARALLEL DO DEFAULT(NONE) SHARED(M,N,XG,DS) PRIVATE(P,Q)
    DO Q = 1, N
       DO P = 1, Q-1
          XG(P,Q) = X_ZERO
       END DO
       XG(Q,Q) = DS(Q)
       DO P = Q+1, M
          XG(P,Q) = X_ZERO
       END DO
    END DO
    !$OMP END PARALLEL DO

    CALL XLAROR('L', 'N', M, N, XG, M, ISEED, XWORK, INFO)
    IF (INFO .NE. 0) RETURN

    CALL XLAROR('R', 'N', M, N, XG, M, ISEED, XWORK, INFO)
    IF (INFO .NE. 0) RETURN

    !$OMP PARALLEL DO DEFAULT(NONE) SHARED(M,N,XG,ZG) PRIVATE(P,Q)
    DO Q = 1, N
       DO P = 1, M
          ZG(P,Q) = DCMPLX(DBLE(REAL(XG(P,Q))), DBLE(AIMAG(XG(P,Q))))
       END DO
    END DO
    !$OMP END PARALLEL DO
  END SUBROUTINE ZGENDAT
END MODULE DATGEN
