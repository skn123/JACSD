SUBROUTINE DJACV0_PREPARE_F(STRAT, LDA, M, N, SWP, TOL, IWORK, LIWORK, INFO)
  IMPLICIT NONE

  INTEGER, INTENT(IN) :: STRAT, LDA, M, N
  INTEGER, INTENT(INOUT) :: SWP
  DOUBLE PRECISION, INTENT(INOUT) :: TOL
  INTEGER, INTENT(OUT), ALLOCATABLE :: IWORK(:)
  !DIR $ ATTRIBUTES ALIGN: MALIGN_B:: IWORK
!IBM* ALIGN(MALIGN_B, IWORK)
  INTEGER, INTENT(OUT) :: LIWORK, INFO

  INTEGER :: JS(JSMLEN), PIV(2,MAX(1,N/2))
  !DIR$ ATTRIBUTES ALIGN: MALIGN_B:: JS, PIV
!IBM* ALIGN(MALIGN_B, IWORK, JS, PIV)

  INTEGER :: STEPS, N_2, MINWRK, R, I, J

  !DIR$ ASSUME (MOD(LDA,D_VEC_LEN) .EQ. 0)

  INFO = 0

  IF (STRAT .LT. 0) THEN
     INFO = -1
     RETURN
  END IF
  IF (LDA .LE. 0) THEN
     INFO = -2
     RETURN
  END IF
  IF ((M .LE. 0) .OR. (M .GT. LDA) .OR. (M .GT. N) .OR. (MOD(M,D_VEC_LEN) .NE. 0)) THEN
     INFO = -3
     RETURN
  END IF
  IF ((N .LE. 0) .OR. (N .GT. LDA) .OR. (N .GT. M) .OR. (MOD(N,2*D_VEC_LEN) .NE. 0)) THEN
     INFO = -4
     RETURN
  END IF
  IF (SWP .LE. 0) THEN
     INFO = -5
     RETURN
  END IF

  IF (TOL .LT. D_ZERO) THEN
     TOL = SQRT(DBLE(M)) * SCALE(EPSILON(D_ONE),-1)
  ELSE IF (TOL .EQ. D_ZERO) THEN
     TOL = M * SCALE(EPSILON(D_ONE),-1)
  END IF

  CALL JSTRAT_INIT(JS, STRAT, N, STEPS)
  IF (STEPS .LE. 0) THEN
     INFO = -1
     RETURN
  ELSE IF (STEPS .EQ. N) THEN
     SWP = -SWP
  ELSE IF (STEPS .NE. (N-1)) THEN
     INFO = -1
     RETURN
  END IF

  N_2 = N / 2
  MINWRK = STEPS * N_2
  R = MOD(MINWRK, I_VEC_LEN)
  IF (R .NE. 0) MINWRK = MINWRK + (I_VEC_LEN - R)

  LIWORK = 2 * MINWRK
  IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
  ALLOCATE(IWORK(LIWORK))

  R = 1
  DO I = 1, STEPS
     CALL JSTRAT_NEXT(JS, PIV, INFO)
     IF (INFO .NE. N_2) THEN
        INFO = 0
        RETURN
     END IF
     DO J = 1, N_2
        IWORK(R) = PIV(1,J) * LDA ! P
        IWORK(MINWRK + R) = PIV(2,J) * LDA ! Q
        R = R + 1
     END DO
  END DO

  INFO = STEPS
END SUBROUTINE DJACV0_PREPARE_F

SUBROUTINE DJACV0_EXECUTE_F(LDA, M, N, G, V, TOL, SWP, IWORK, INFO)
  USE, INTRINSIC :: ISO_C_BINDING
  IMPLICIT NONE

#ifdef USE_X200
  INTERFACE
     INTEGER(8) FUNCTION DJACV0_EXECUTE_C(M, N, G, V, TOL, SWP, IWORK, INFO) BIND(C,name='avx512_djacv0_execute')
       INTEGER(4), VALUE :: M, N, SWP
       REAL(8), INTENT(INOUT) :: G(*), V(*)
       REAL(8), VALUE :: TOL
       INTEGER(8), INTENT(IN) :: IWORK(*)
       INTEGER(4), INTENT(OUT) :: INFO
     END FUNCTION DJACV0_EXECUTE_C
  END INTERFACE
#else
  INTERFACE
     INTEGER(8) FUNCTION DJACV0_EXECUTE_C(M, N, G, V, TOL, SWP, IWORK, INFO) BIND(C,name='avx2_fma_djacv0_execute')
       INTEGER(4), VALUE :: M, N, SWP
       REAL(8), INTENT(INOUT) :: G(*), V(*)
       REAL(8), VALUE :: TOL
       INTEGER(8), INTENT(IN) :: IWORK(*)
       INTEGER(4), INTENT(OUT) :: INFO
     END FUNCTION DJACV0_EXECUTE_C
  END INTERFACE
#endif

  INTEGER, INTENT(IN) :: LDA, M, N, SWP, IWORK(*)
  DOUBLE PRECISION, INTENT(IN) :: TOL
  DOUBLE PRECISION, INTENT(INOUT) :: G(LDA,N)
  DOUBLE PRECISION, INTENT(OUT) :: V(LDA,N)
  INTEGER, INTENT(OUT) :: INFO(2)
  EXTERNAL :: DLASET

  INTEGER :: JNFO
  INTEGER(c_int) :: JNFO2(2)
  EQUIVALENCE (JNFO, JNFO2)

  !DIR$ ASSUME_ALIGNED G:MALIGN_B,V:MALIGN_B,IWORK:MALIGN_B
  !DIR$ ASSUME (MOD(LDA,D_VEC_LEN) .EQ. 0)

  JNFO2(2) = INT(SWP,c_int)
  CALL DLASET('A', N, N, D_ZERO, D_ONE, V, LDA)
  INFO(1) = INT(DJACV0_EXECUTE_C(INT(M,c_int), INT(N,c_int), G, V, TOL, JNFO2(2), IWORK, JNFO2(1)))
  INFO(2) = JNFO
END SUBROUTINE DJACV0_EXECUTE_F
