PROGRAM xDJAC0

  USE CSD
  IMPLICIT NONE

  LOGICAL, PARAMETER :: FAST = .FALSE.
  INTEGER, PARAMETER :: MAXCYC = HUGE(0)
  DOUBLE PRECISION, PARAMETER :: TOL = D_ZERO

  INTEGER :: M, N, J, T
  CHARACTER(LEN=256) :: F
  INTEGER :: LDG, LDV, LWORK, LIWORK
  INTEGER :: NROT(2), CLK(3), IWORK1(I_CL1_LEN)
  INTEGER :: R, IOU, INFO(2)
  DOUBLE PRECISION :: WORK1(D_CL1_LEN)

  DOUBLE PRECISION, ALLOCATABLE :: G(:,:), V(:,:), SIGMA(:), WORK(:)
  INTEGER, ALLOCATABLE :: IWORK(:)
  !DIR$ ATTRIBUTES ALIGN: MALIGN_B:: G,V,SIGMA, WORK,IWORK, WORK1,IWORK1

  INTEGER, INTRINSIC :: MOD

  CALL READCL(M, N, J, T, F, INFO(2))
  IF (INFO(2) .NE. 0) STOP 'xDJAC0.exe M N J T F'
  IF (M .LE. 0) STOP 'M <= 0'
  IF (N .LE. 0) STOP 'N <= 0'
  IF (N .GT. M) STOP 'N > M'

  IOU = GET_IOUNIT('N')
  IF (IOU .LT. 0) STOP 'IOU < 0'

  CALL BIN_OPEN(IOU, TRIM(F), 'OLD', 'READ', INFO(2))
  IF (INFO(2) .NE. 0) STOP 'BIN_OPEN(.bin)'

  LDG = M
  R = MOD(LDG, D_CL1_LEN)
  IF (R .NE. 0) LDG = LDG + (D_CL1_LEN - R)

  ALLOCATE(G(LDG,N))

  CALL BIN_READ_2D(IOU, LDG, G, M, N, INFO(2))
  IF (INFO(2) .NE. 0) STOP 'BIN_READ_2D(G)'

  CALL BIN_CLOSE(IOU, INFO(2))
  IF (INFO(2) .NE. 0) STOP 'BIN_CLOSE(.bin)'

  LDV = N
  R = MOD(LDV, D_CL1_LEN)
  IF (R .NE. 0) LDV = LDV + (D_CL1_LEN - R)

  ALLOCATE(V(LDV,N))
  ALLOCATE(SIGMA(N))

  INFO(2) = BLAS_PREPARE()
  IF (INFO(2) .NE. 0) STOP 'BLAS_PREPARE'

  LWORK = 0
  LIWORK = 0
  CALL DJAC0(FAST, M, N, G, LDG, V, LDV, MAXCYC, T, J, TOL, SIGMA, WORK1, LWORK, IWORK1, LIWORK, NROT, INFO)
  IF (INFO(1) .LT. 0) STOP 'DJAC0(workspace query)'
  IF (INFO(1) .GT. 0) THEN
     LWORK = INFO(1)
     ALLOCATE(WORK(LWORK))
  END IF
  IF (INFO(2) .GT. 0) THEN
     LIWORK = INFO(2)
     ALLOCATE(IWORK(LIWORK))
  END IF

  CALL TIMER_START(CLK)
  CALL DJAC0(FAST, M, N, G, LDG, V, LDV, MAXCYC, T, J, TOL, SIGMA, WORK, LWORK, IWORK, LIWORK, NROT, INFO)
  CALL TIMER_STOP(CLK)

  IF (LIWORK .GT. 0) DEALLOCATE(IWORK)
  IF (LWORK .GT. 0) DEALLOCATE(WORK)

  WRITE (*,'(I3,A,I3,A,I3,A,I3,A,I10,A,I10,A)',ADVANCE='NO') INFO(1),',',INFO(2),',',M,',',N,',',NROT(1),',',NROT(2),','
  CALL TIMER_PRINT(CLK)

  CALL BIN_OPEN(IOU, (TRIM(F)//'.out'), 'REPLACE', 'WRITE', INFO(2))
  IF (INFO(2) .NE. 0) STOP 'BIN_OPEN(.out)'

  CALL BIN_WRITE_1D(IOU, SIGMA, N, INFO(2))
  DEALLOCATE(SIGMA)
  IF (INFO(2) .NE. 0) STOP 'BIN_WRITE_1D(SIGMA)'

  CALL BIN_WRITE_2D(IOU, LDV, V, N, N, INFO(2))
  DEALLOCATE(V)
  IF (INFO(2) .NE. 0) STOP 'BIN_WRITE_2D(V)'

  CALL BIN_WRITE_2D(IOU, LDG, G, M, N, INFO(2))
  DEALLOCATE(G)
  IF (INFO(2) .NE. 0) STOP 'BIN_WRITE_2D(G)'

  CALL BIN_CLOSE(IOU, INFO(2))
  IF (INFO(2) .NE. 0) STOP 'BIN_CLOSE(.out)'

CONTAINS

  SUBROUTINE READCL(M, N, J, T, F, INFO)

    INTEGER, INTENT(OUT) :: M, N, J, T, INFO
    CHARACTER(LEN=*), INTENT(OUT) :: F

#ifndef USE_IBM
    INTEGER, INTRINSIC :: COMMAND_ARGUMENT_COUNT
#endif
    INTRINSIC :: GET_COMMAND_ARGUMENT

    INFO = COMMAND_ARGUMENT_COUNT()
    IF (INFO .EQ. 5) THEN
       CALL GET_COMMAND_ARGUMENT(1, F)
       READ (F,*) M

       CALL GET_COMMAND_ARGUMENT(2, F)
       READ (F,*) N

       CALL GET_COMMAND_ARGUMENT(3, F)
       READ (F,*) J

       CALL GET_COMMAND_ARGUMENT(4, F)
       READ (F,*) T

       CALL GET_COMMAND_ARGUMENT(5, F)
    END IF
    INFO = INFO - 5

  END SUBROUTINE READCL

END PROGRAM xDJAC0
