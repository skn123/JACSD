PROGRAM xDJAC2

  USE CSD
#ifdef USE_MPI
#ifdef USE_GNU
  USE MPI_F08
#else
  USE MPI
#endif
#endif
  IMPLICIT NONE

  LOGICAL, PARAMETER :: FAST = .FALSE.
  INTEGER, PARAMETER :: MXCYC2 = HUGE(0)
  DOUBLE PRECISION, PARAMETER :: TOL = D_ZERO

  INTEGER :: M, N
  CHARACTER(LEN=256) :: F
  INTEGER :: LDG, LDV, MAXTHR(3), MAXCYC(3), JSTRAT(3), LWORK, LIWORK
  INTEGER :: R, IOU, NROT(2), CLK(3), INFO(2), IWORK1(I_CL1_LEN)
  DOUBLE PRECISION :: WORK1(D_CL1_LEN)

  DOUBLE PRECISION, ALLOCATABLE :: G(:,:), V(:,:), SIGMA(:), WORK(:)
  INTEGER, ALLOCATABLE :: IWORK(:)
#ifdef USE_X200
  !TODO: GSH,VSH part of WORK should NOT go to FASTMEM, since it might not fit!
  !TODO: Split into WORK for GSH,VSH, and WORK1 in FASTMEM for the rest.
  !DIR$ ATTRIBUTES FASTMEM, ALIGN: MALIGN_B:: WORK,IWORK
  !DIR$ ATTRIBUTES ALIGN: MALIGN_B:: G,V, SIGMA, WORK1,IWORK1
#else
  !DIR$ ATTRIBUTES ALIGN: MALIGN_B:: G,V, SIGMA, WORK,IWORK, WORK1,IWORK1
#endif
!IBM* ALIGN(MALIGN_B, G,V, SIGMA, WORK,IWORK, WORK1,IWORK1)

  INTEGER, INTRINSIC :: MOD

#ifdef USE_MPI
  R = MPI_THREAD_MULTIPLE
  CALL MPI_INIT_THREAD(R, INFO(1), INFO(2))
  IF (INFO(2) .NE. MPI_SUCCESS) STOP 'MPI_INIT_THREAD'
#endif

  CALL READCL(M, N, JSTRAT(3), MAXCYC(3), MAXTHR(3), JSTRAT(2), MAXCYC(2), MAXTHR(2), JSTRAT(1), MAXTHR(1), F, INFO(2))
  IF (INFO(2) .NE. 0) STOP 'xDJAC2.exe M N J0 C0 T0 J1 C1 T1 J2 T2 F'
  IF (M .LE. 0) STOP 'M <= 0'
  IF (N .LE. 0) STOP 'N <= 0'
  IF (N .GT. M) STOP 'N > M'
  MAXCYC(1) = MXCYC2

  IOU = GET_IOUNIT('N')
  IF (IOU .LT. 0) STOP 'IOU < 0'

  CALL BIN_OPEN(IOU, TRIM(F), 'OLD', 'READ', INFO(2))
  IF (INFO(2) .NE. 0) STOP 'BIN_OPEN(.bin)'

  LDG = M
  R = MOD(LDG, D_CL1_LEN)
  IF (R .NE. 0) LDG = LDG + (D_CL1_LEN - R)

  ALLOCATE(G(LDG,N)); G = D_ZERO

  CALL BIN_READ_2D(IOU, LDG, G, M, N, INFO(2))
  IF (INFO(2) .NE. 0) STOP 'BIN_READ_2D(G)'

  CALL BIN_CLOSE(IOU, INFO(2))
  IF (INFO(2) .NE. 0) STOP 'BIN_CLOSE(.bin)'

  LDV = N
  R = MOD(LDV, D_CL1_LEN)
  IF (R .NE. 0) LDV = LDV + (D_CL1_LEN - R)

  ALLOCATE(V(LDV,N)); V = D_ZERO
  ALLOCATE(SIGMA(N)); SIGMA = D_ZERO

  INFO(2) = BLAS_PREPARE()
  IF (INFO(2) .LT. 0) STOP 'BLAS_PREPARE'

  LWORK = 0
  LIWORK = 0
  CALL DJAC2(FAST, M, N, G, LDG, V, LDV, MAXCYC, MAXTHR, JSTRAT, TOL, SIGMA,&
       WORK1, LWORK, IWORK1, LIWORK, NROT, INFO)
  IF (INFO(1) .LT. 0) STOP 'DJAC2(workspace query)'
  IF (INFO(1) .GT. 0) THEN
     LWORK = INFO(1)
     ALLOCATE(WORK(LWORK)); WORK = D_ZERO
  END IF
  IF (INFO(2) .GT. 0) THEN
     LIWORK = INFO(2)
     ALLOCATE(IWORK(LIWORK)); IWORK = 0
  END IF

  CALL TIMER_START(CLK)
  CALL DJAC2(FAST, M, N, G, LDG, V, LDV, MAXCYC, MAXTHR, JSTRAT, TOL, SIGMA,&
       WORK, LWORK, IWORK, LIWORK, NROT, INFO)
  CALL TIMER_STOP(CLK)

  IF (LIWORK .GT. 0) DEALLOCATE(IWORK)
  IF (LWORK .GT. 0) DEALLOCATE(WORK)

  WRITE (*,'(I5,A,I5,A,I5,A,I5,A,I10,A,I10,A)',ADVANCE='NO') INFO(1),',',INFO(2), ',',M,',',N,',', NROT(1),',',NROT(2), ','
  CALL TIMER_PRINT(CLK)

  CALL BIN_OPEN(IOU, (TRIM(F)//'.out'), 'REPLACE', 'WRITE', INFO(2))
  IF (INFO(2) .NE. 0) STOP 'BIN_OPEN(.out)'

  CALL BIN_WRITE_1D(IOU, SIGMA, N, INFO(2))
  DEALLOCATE(SIGMA)
  IF (INFO(2) .NE. 0) STOP 'BIN_WRITE_1D(SIGMA)'

  CALL BIN_WRITE_2D(IOU, LDV, V, N, N, INFO(2))
  DEALLOCATE(V)
  IF (INFO(2) .NE. 0) STOP 'BIN_WRITE_2D(V)'

  CALL BIN_WRITE_2D(IOU, LDG, G, M, N, INFO(2))
  DEALLOCATE(G)
  IF (INFO(2) .NE. 0) STOP 'BIN_WRITE_2D(G)'

  CALL BIN_CLOSE(IOU, INFO(2))
  IF (INFO(2) .NE. 0) STOP 'BIN_CLOSE(.out)'

#ifdef USE_MPI
  CALL MPI_FINALIZE(INFO(2))
  IF (INFO(2) .NE. MPI_SUCCESS) STOP 'MPI_FINALIZE'
#endif

CONTAINS

  SUBROUTINE READCL(M, N, J0, C0, T0, J1, C1, T1, J2, T2, F, INFO)

    INTEGER, INTENT(OUT) :: M, N, J0, C0, T0, J1, C1, T1, J2, T2, INFO
    CHARACTER(LEN=*), INTENT(OUT) :: F

#ifndef USE_IBM
    INTEGER, INTRINSIC :: COMMAND_ARGUMENT_COUNT
#endif
    INTRINSIC :: GET_COMMAND_ARGUMENT

    INFO = COMMAND_ARGUMENT_COUNT()
    IF (INFO .EQ. 11) THEN
       CALL GET_COMMAND_ARGUMENT(1, F)
       READ (F,*) M

       CALL GET_COMMAND_ARGUMENT(2, F)
       READ (F,*) N

       CALL GET_COMMAND_ARGUMENT(3, F)
       READ (F,*) J0

       CALL GET_COMMAND_ARGUMENT(4, F)
       READ (F,*) C0

       CALL GET_COMMAND_ARGUMENT(5, F)
       READ (F,*) T0

       CALL GET_COMMAND_ARGUMENT(6, F)
       READ (F,*) J1

       CALL GET_COMMAND_ARGUMENT(7, F)
       READ (F,*) C1

       CALL GET_COMMAND_ARGUMENT(8, F)
       READ (F,*) T1

       CALL GET_COMMAND_ARGUMENT(9, F)
       READ (F,*) J2

       CALL GET_COMMAND_ARGUMENT(10, F)
       READ (F,*) T2

       CALL GET_COMMAND_ARGUMENT(11, F)
    END IF
    INFO = INFO - 11

  END SUBROUTINE READCL

END PROGRAM xDJAC2
